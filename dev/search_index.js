var documenterSearchIndex = {"docs":
[{"location":"neighborhoods/#Neighborhood-Analysis","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"MetricSpaces.jl provides tools for analyzing the local structure of metric spaces through neighborhood-based computations. These methods are essential for understanding local geometry, density, and topological properties.","category":"page"},{"location":"neighborhoods/#k-Nearest-Neighbors","page":"Neighborhood Analysis","title":"k-Nearest Neighbors","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"Find the k closest points to a given query point.","category":"page"},{"location":"neighborhoods/#k_neighbors","page":"Neighborhood Analysis","title":"k_neighbors","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"k_neighbors(X::MetricSpace, query_point, k::Int; d=dist_euclidean)","category":"page"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"Example:","category":"page"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"# Create sample data\npoints = [[0.0, 0.0], [1.0, 0.0], [0.0, 1.0], [1.0, 1.0], [2.0, 0.0], [0.0, 2.0]]\nX = EuclideanSpace(points)\n\n# Find 3 nearest neighbors of origin\nquery = [0.0, 0.0]\nneighbors = k_neighbors(X, query, 3)\n\nprintln(\"3 nearest neighbors of $query:\")\nfor (i, neighbor_idx) in enumerate(neighbors)\n    point = X[neighbor_idx]\n    dist = dist_euclidean(query, point)\n    println(\"  $i: Point $neighbor_idx = $point (distance: $(round(dist, digits=3)))\")\nend","category":"page"},{"location":"neighborhoods/#Properties-of-k-NN","page":"Neighborhood Analysis","title":"Properties of k-NN","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"Asymmetry: If A is a k-neighbor of B, B might not be a k-neighbor of A\nLocality: Captures local structure around each point\nScale-free: Adapts to local density variations","category":"page"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"# Analyze k-NN asymmetry\nfunction analyze_knn_asymmetry(X::EuclideanSpace, k::Int)\n    n = length(X)\n    asymmetric_pairs = 0\n    total_pairs = 0\n    \n    for i in 1:n\n        neighbors_i = k_neighbors(X, X[i], k)\n        \n        for neighbor_idx in neighbors_i\n            total_pairs += 1\n            neighbors_j = k_neighbors(X, X[neighbor_idx], k)\n            \n            if !(i in neighbors_j)\n                asymmetric_pairs += 1\n            end\n        end\n    end\n    \n    asymmetry_rate = asymmetric_pairs / total_pairs\n    println(\"k-NN asymmetry rate: $(round(asymmetry_rate * 100, digits=1))%\")\n    return asymmetry_rate\nend\n\nasymmetry = analyze_knn_asymmetry(X, 2)","category":"page"},{"location":"neighborhoods/#Distance-to-Measure","page":"Neighborhood Analysis","title":"Distance-to-Measure","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"Compute density-based measures for outlier detection and filtering.","category":"page"},{"location":"neighborhoods/#distance_to_measure","page":"Neighborhood Analysis","title":"distance_to_measure","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"distance_to_measure(X::MetricSpace, mass_parameter::Float64; d=dist_euclidean)","category":"page"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"The distance-to-measure d_Î¼m(x) for a point x is the minimum radius needed for a ball centered at x to contain at least mass m of the total measure.","category":"page"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"Example:","category":"page"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"# Create data with outliers\nnormal_points = [randn(2) for _ in 1:50]  # Clustered points\noutliers = [[10.0, 10.0], [-8.0, -8.0]]   # Clear outliers\nall_points = vcat(normal_points, outliers)\nX_outliers = EuclideanSpace(all_points)\n\n# Compute distance to measure with 10% mass\nmass_param = 0.1\ndtm_values = distance_to_measure(X_outliers, mass_param)\n\nprintln(\"Distance to measure analysis:\")\nprintln(\"Normal points (first 5): \", round.(dtm_values[1:5], digits=3))\nprintln(\"Outliers: \", round.(dtm_values[end-1:end], digits=3))\n\n# Identify outliers (high DTM values)\nthreshold = quantile(dtm_values, 0.9)  # Top 10% as outliers\noutlier_indices = findall(x -> x > threshold, dtm_values)\nprintln(\"Detected outlier indices: \", outlier_indices)","category":"page"},{"location":"neighborhoods/#DTM-Applications","page":"Neighborhood Analysis","title":"DTM Applications","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"Density Estimation:","category":"page"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"function estimate_density_dtm(X::EuclideanSpace, mass_param=0.05)\n    dtm_vals = distance_to_measure(X, mass_param)\n    # Density inversely related to DTM\n    densities = 1.0 ./ (dtm_vals .+ 1e-10)  # Add small value to avoid division by zero\n    return densities ./ sum(densities)  # Normalize\nend\n\ndensities = estimate_density_dtm(X_outliers)","category":"page"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"Robust Filtering:","category":"page"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"function robust_filter(X::EuclideanSpace, mass_param=0.1, quantile_threshold=0.8)\n    dtm_vals = distance_to_measure(X, mass_param)\n    threshold = quantile(dtm_vals, quantile_threshold)\n    \n    # Keep points with low DTM (high density regions)\n    filtered_indices = findall(x -> x <= threshold, dtm_vals)\n    return filtered_indices\nend\n\nfiltered_indices = robust_filter(X_outliers, 0.1, 0.8)\nfiltered_points = X_outliers[filtered_indices]\nprintln(\"Filtered from $(length(X_outliers)) to $(length(filtered_points)) points\")","category":"page"},{"location":"neighborhoods/#Eccentricity","page":"Neighborhood Analysis","title":"Eccentricity","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"Measure how \"central\" each point is within the metric space.","category":"page"},{"location":"neighborhoods/#excentricity","page":"Neighborhood Analysis","title":"excentricity","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"excentricity(X::MetricSpace; d=dist_euclidean)","category":"page"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"The eccentricity of a point is its maximum distance to any other point in the space.","category":"page"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"Example:","category":"page"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"# Create data with clear center and boundary points\ncenter_points = [0.1 * randn(2) for _ in 1:20]  # Tight cluster at origin\nboundary_points = [5.0 * normalize(randn(2)) for _ in 1:10]  # Points on boundary\nmixed_data = vcat(center_points, boundary_points)\nX_mixed = EuclideanSpace(mixed_data)\n\n# Compute eccentricity\neccentricities = excentricity(X_mixed)\n\nprintln(\"Eccentricity analysis:\")\nprintln(\"Center points (first 5): \", round.(eccentricities[1:5], digits=3))\nprintln(\"Boundary points (last 5): \", round.(eccentricities[end-4:end], digits=3))\n\n# Find most central point (minimum eccentricity)\nmost_central_idx = argmin(eccentricities)\nmost_eccentric_idx = argmax(eccentricities)\n\nprintln(\"Most central point: index $most_central_idx, eccentricity $(round(eccentricities[most_central_idx], digits=3))\")\nprintln(\"Most eccentric point: index $most_eccentric_idx, eccentricity $(round(eccentricities[most_eccentric_idx], digits=3))\")","category":"page"},{"location":"neighborhoods/#Eccentricity-Applications","page":"Neighborhood Analysis","title":"Eccentricity Applications","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"Geometric Center Finding:","category":"page"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"function find_geometric_center(X::EuclideanSpace)\n    ecc_values = excentricity(X)\n    center_idx = argmin(ecc_values)\n    return center_idx, X[center_idx]\nend\n\ncenter_idx, center_point = find_geometric_center(X_mixed)\nprintln(\"Geometric center: $center_point at index $center_idx\")","category":"page"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"Boundary Detection:","category":"page"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"function detect_boundary_points(X::EuclideanSpace, percentile=90)\n    ecc_values = excentricity(X)\n    threshold = quantile(ecc_values, percentile/100)\n    boundary_indices = findall(x -> x >= threshold, ecc_values)\n    return boundary_indices\nend\n\nboundary_indices = detect_boundary_points(X_mixed, 80)\nprintln(\"Boundary points (top 20%): \", boundary_indices)","category":"page"},{"location":"neighborhoods/#Local-Dimension-Estimation","page":"Neighborhood Analysis","title":"Local Dimension Estimation","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"Estimate the local intrinsic dimension around each point.","category":"page"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"using LinearAlgebra\n\nfunction estimate_local_dimension(X::EuclideanSpace, k::Int=10; method=:pca)\n    local_dimensions = Float64[]\n    \n    for i in 1:length(X)\n        # Get k nearest neighbors\n        neighbor_indices = k_neighbors(X, X[i], k)\n        neighbor_points = [X[j] for j in neighbor_indices]\n        \n        if method == :pca\n            # Center the neighbor points\n            center = mean(neighbor_points)\n            centered_points = [p .- center for p in neighbor_points]\n            \n            # Create data matrix (points as columns)\n            data_matrix = hcat(centered_points...)\n            \n            # Compute SVD\n            U, S, V = svd(data_matrix)\n            \n            # Estimate dimension based on singular value decay\n            # Simple approach: count significant singular values\n            total_variance = sum(S.^2)\n            cumulative_variance = cumsum(S.^2) / total_variance\n            \n            # Find dimension needed to capture 90% of variance\n            dim_estimate = findfirst(x -> x > 0.9, cumulative_variance)\n            dim_estimate = dim_estimate === nothing ? length(S) : dim_estimate\n            \n        else\n            # Fallback: use ambient dimension\n            dim_estimate = length(X[1])\n        end\n        \n        push!(local_dimensions, dim_estimate)\n    end\n    \n    return local_dimensions\nend\n\n# Example usage\nlocal_dims = estimate_local_dimension(X_mixed, 5)\nprintln(\"Local dimension estimates:\")\nprintln(\"Mean: $(round(mean(local_dims), digits=2))\")\nprintln(\"Range: $(minimum(local_dims)) - $(maximum(local_dims))\")","category":"page"},{"location":"neighborhoods/#Neighborhood-Graphs","page":"Neighborhood Analysis","title":"Neighborhood Graphs","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"Construct graphs based on neighborhood relationships.","category":"page"},{"location":"neighborhoods/#k-NN-Graph","page":"Neighborhood Analysis","title":"k-NN Graph","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"using Graphs\n\nfunction build_knn_graph(X::EuclideanSpace, k::Int)\n    n = length(X)\n    g = SimpleGraph(n)\n    \n    for i in 1:n\n        neighbors = k_neighbors(X, X[i], k)\n        for neighbor_idx in neighbors\n            if neighbor_idx != i  # Avoid self-loops\n                add_edge!(g, i, neighbor_idx)\n            end\n        end\n    end\n    \n    return g\nend\n\nknn_graph = build_knn_graph(X, 2)\nprintln(\"k-NN graph properties:\")\nprintln(\"Nodes: $(nv(knn_graph))\")\nprintln(\"Edges: $(ne(knn_graph))\")\nprintln(\"Connected components: $(length(connected_components(knn_graph)))\")","category":"page"},{"location":"neighborhoods/#Îµ-neighborhood-Graph","page":"Neighborhood Analysis","title":"Îµ-neighborhood Graph","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"function build_epsilon_graph(X::EuclideanSpace, Îµ::Float64)\n    n = length(X)\n    g = SimpleGraph(n)\n    \n    for i in 1:n\n        neighbors = ball_ids(X, X[i], Îµ)\n        for neighbor_idx in neighbors\n            if neighbor_idx != i && neighbor_idx > i  # Avoid self-loops and duplicates\n                add_edge!(g, i, neighbor_idx)\n            end\n        end\n    end\n    \n    return g\nend\n\neps_graph = build_epsilon_graph(X, 1.5)\nprintln(\"Îµ-neighborhood graph properties:\")\nprintln(\"Nodes: $(nv(eps_graph))\")\nprintln(\"Edges: $(ne(eps_graph))\")","category":"page"},{"location":"neighborhoods/#Advanced-Neighborhood-Analysis","page":"Neighborhood Analysis","title":"Advanced Neighborhood Analysis","text":"","category":"section"},{"location":"neighborhoods/#Neighborhood-Stability","page":"Neighborhood Analysis","title":"Neighborhood Stability","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"Analyze how neighborhoods change under perturbations:","category":"page"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"function neighborhood_stability(X::EuclideanSpace, k::Int, noise_level=0.1, n_trials=10)\n    stability_scores = Float64[]\n    \n    for i in 1:length(X)\n        original_neighbors = Set(k_neighbors(X, X[i], k))\n        overlap_scores = Float64[]\n        \n        for trial in 1:n_trials\n            # Add noise to the query point\n            noisy_point = X[i] .+ noise_level * randn(length(X[i]))\n            noisy_neighbors = Set(k_neighbors(X, noisy_point, k))\n            \n            # Compute Jaccard similarity\n            intersection_size = length(intersect(original_neighbors, noisy_neighbors))\n            union_size = length(union(original_neighbors, noisy_neighbors))\n            jaccard = intersection_size / union_size\n            \n            push!(overlap_scores, jaccard)\n        end\n        \n        push!(stability_scores, mean(overlap_scores))\n    end\n    \n    return stability_scores\nend\n\nstability = neighborhood_stability(X, 3, 0.05, 5)\nprintln(\"Neighborhood stability (mean): $(round(mean(stability), digits=3))\")","category":"page"},{"location":"neighborhoods/#Multi-scale-Neighborhoods","page":"Neighborhood Analysis","title":"Multi-scale Neighborhoods","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"Analyze neighborhoods at different scales:","category":"page"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"function multiscale_neighborhood_analysis(X::EuclideanSpace, point_idx::Int, radii=[0.5, 1.0, 1.5, 2.0])\n    analysis = Dict{Float64, Dict{String, Any}}()\n    \n    for r in radii\n        neighbors = ball_ids(X, X[point_idx], r)\n        neighbor_points = [X[i] for i in neighbors]\n        \n        # Compute neighborhood statistics\n        n_neighbors = length(neighbors)\n        \n        if n_neighbors > 1\n            # Average distance to neighbors\n            center = X[point_idx]\n            distances = [dist_euclidean(center, p) for p in neighbor_points]\n            avg_dist = mean(distances)\n            std_dist = std(distances)\n            \n            # Neighborhood \"spread\"\n            if n_neighbors > 2\n                centroid = mean(neighbor_points)\n                spreads = [norm(p .- centroid) for p in neighbor_points]\n                neighborhood_spread = mean(spreads)\n            else\n                neighborhood_spread = 0.0\n            end\n        else\n            avg_dist = 0.0\n            std_dist = 0.0\n            neighborhood_spread = 0.0\n        end\n        \n        analysis[r] = Dict(\n            \"n_neighbors\" => n_neighbors,\n            \"avg_distance\" => avg_dist,\n            \"std_distance\" => std_dist,\n            \"neighborhood_spread\" => neighborhood_spread\n        )\n    end\n    \n    return analysis\nend\n\n# Analyze neighborhoods around the first point\nmultiscale_analysis = multiscale_neighborhood_analysis(X, 1)\nprintln(\"Multi-scale neighborhood analysis for point 1:\")\nfor (radius, stats) in sort(collect(multiscale_analysis))\n    println(\"Radius $radius:\")\n    println(\"  Neighbors: $(stats[\"n_neighbors\"])\")\n    println(\"  Avg distance: $(round(stats[\"avg_distance\"], digits=3))\")\n    println(\"  Neighborhood spread: $(round(stats[\"neighborhood_spread\"], digits=3))\")\nend","category":"page"},{"location":"neighborhoods/#Applications-in-Data-Analysis","page":"Neighborhood Analysis","title":"Applications in Data Analysis","text":"","category":"section"},{"location":"neighborhoods/#Clustering-Validation","page":"Neighborhood Analysis","title":"Clustering Validation","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"Use neighborhood analysis to validate clustering results:","category":"page"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"function validate_clustering_with_neighborhoods(X::EuclideanSpace, cluster_labels, k::Int=5)\n    n_clusters = maximum(cluster_labels)\n    intra_cluster_cohesion = Float64[]\n    \n    for cluster_id in 1:n_clusters\n        cluster_points = findall(x -> x == cluster_id, cluster_labels)\n        \n        if length(cluster_points) > k\n            cohesion_scores = Float64[]\n            \n            for point_idx in cluster_points\n                neighbors = k_neighbors(X, X[point_idx], k)\n                # Count how many neighbors are in the same cluster\n                same_cluster_neighbors = sum(cluster_labels[neighbors] .== cluster_id)\n                cohesion = same_cluster_neighbors / k\n                push!(cohesion_scores, cohesion)\n            end\n            \n            push!(intra_cluster_cohesion, mean(cohesion_scores))\n        end\n    end\n    \n    return mean(intra_cluster_cohesion)\nend\n\n# Example with simple clustering\ncluster_labels = [1, 1, 1, 2, 2, 2]  # Simple manual clustering\ncohesion = validate_clustering_with_neighborhoods(X, cluster_labels, 2)\nprintln(\"Clustering cohesion score: $(round(cohesion, digits=3))\")","category":"page"},{"location":"neighborhoods/#Anomaly-Detection","page":"Neighborhood Analysis","title":"Anomaly Detection","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"Combine multiple neighborhood-based measures:","category":"page"},{"location":"neighborhoods/","page":"Neighborhood Analysis","title":"Neighborhood Analysis","text":"function comprehensive_anomaly_detection(X::EuclideanSpace)\n    # Compute multiple measures\n    dtm_vals = distance_to_measure(X, 0.1)\n    ecc_vals = excentricity(X)\n    \n    # Local density (inverse of average k-NN distance)\n    k = min(5, length(X) - 1)\n    local_densities = Float64[]\n    \n    for i in 1:length(X)\n        if length(X) > 1\n            neighbors = k_neighbors(X, X[i], min(k, length(X)-1))\n            avg_dist = mean([dist_euclidean(X[i], X[j]) for j in neighbors if j != i])\n            push!(local_densities, 1.0 / (avg_dist + 1e-10))\n        else\n            push!(local_densities, 1.0)\n        end\n    end\n    \n    # Normalize measures to [0, 1]\n    dtm_norm = (dtm_vals .- minimum(dtm_vals)) ./ (maximum(dtm_vals) - minimum(dtm_vals) + 1e-10)\n    ecc_norm = (ecc_vals .- minimum(ecc_vals)) ./ (maximum(ecc_vals) - minimum(ecc_vals) + 1e-10)\n    density_norm = 1.0 .- ((local_densities .- minimum(local_densities)) ./ (maximum(local_densities) - minimum(local_densities) + 1e-10))\n    \n    # Combine measures (equal weights)\n    anomaly_scores = (dtm_norm .+ ecc_norm .+ density_norm) ./ 3\n    \n    return anomaly_scores\nend\n\nanomaly_scores = comprehensive_anomaly_detection(X_outliers)\nprintln(\"Top 3 anomalies:\")\ntop_anomalies = sortperm(anomaly_scores, rev=true)[1:3]\nfor (rank, idx) in enumerate(top_anomalies)\n    println(\"  $rank: Point $idx (score: $(round(anomaly_scores[idx], digits=3)))\")\nend","category":"page"},{"location":"types/#Core-Types","page":"Core Types","title":"Core Types","text":"","category":"section"},{"location":"types/","page":"Core Types","title":"Core Types","text":"MetricSpaces.jl provides flexible type definitions for representing metric spaces and related geometric structures.","category":"page"},{"location":"types/#MetricSpace","page":"Core Types","title":"MetricSpace","text":"","category":"section"},{"location":"types/","page":"Core Types","title":"Core Types","text":"The fundamental type in the package is MetricSpace{T}, which is simply an alias for Vector{T}:","category":"page"},{"location":"types/","page":"Core Types","title":"Core Types","text":"MetricSpace{T} = Vector{T} where {T}","category":"page"},{"location":"types/","page":"Core Types","title":"Core Types","text":"This design provides maximum flexibility - any collection of objects can form a metric space as long as you can define a distance function between them.","category":"page"},{"location":"types/#Basic-Usage","page":"Core Types","title":"Basic Usage","text":"","category":"section"},{"location":"types/","page":"Core Types","title":"Core Types","text":"# Create a metric space from any vector of objects\npoints = [\"hello\", \"world\", \"foo\", \"bar\"]\nstring_space = MetricSpace(points)\n\n# Define a custom distance function for strings (edit distance, etc.)\nfunction string_distance(s1, s2)\n    # Simple character difference count (not a true edit distance)\n    return sum(c1 != c2 for (c1, c2) in zip(s1, s2)) + abs(length(s1) - length(s2))\nend","category":"page"},{"location":"types/#EuclideanSpace","page":"Core Types","title":"EuclideanSpace","text":"","category":"section"},{"location":"types/","page":"Core Types","title":"Core Types","text":"For numerical computations, EuclideanSpace{N,T} provides optimized handling of points in Euclidean space:","category":"page"},{"location":"types/","page":"Core Types","title":"Core Types","text":"EuclideanSpace{N, T} = MetricSpace{SVector{N, T}} where {N, T}","category":"page"},{"location":"types/#Construction","page":"Core Types","title":"Construction","text":"","category":"section"},{"location":"types/","page":"Core Types","title":"Core Types","text":"The EuclideanSpace constructor ensures all points have the same dimension:","category":"page"},{"location":"types/","page":"Core Types","title":"Core Types","text":"# From a vector of vectors\npoints = [[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]]\nX = EuclideanSpace(points)\n\n# This will throw an error - inconsistent dimensions\n# bad_points = [[1.0, 2.0], [3.0, 4.0, 5.0]]  # 2D and 3D mixed\n# X_bad = EuclideanSpace(bad_points)  # Error!","category":"page"},{"location":"types/#Properties","page":"Core Types","title":"Properties","text":"","category":"section"},{"location":"types/","page":"Core Types","title":"Core Types","text":"# Access individual points\nfirst_point = X[1]\nprintln(\"First point: \", first_point)\n\n# Get space properties\nprintln(\"Number of points: \", length(X))\nprintln(\"Space dimension: \", length(X[1]))\n\n# EuclideanSpace works with any numeric type\nint_points = [[1, 2], [3, 4], [5, 6]]\nX_int = EuclideanSpace(int_points)\n\nfloat32_points = [[1.0f0, 2.0f0], [3.0f0, 4.0f0]]\nX_float32 = EuclideanSpace(float32_points)","category":"page"},{"location":"types/#Matrix-Conversion","page":"Core Types","title":"Matrix Conversion","text":"","category":"section"},{"location":"types/","page":"Core Types","title":"Core Types","text":"Convert between different representations:","category":"page"},{"location":"types/","page":"Core Types","title":"Core Types","text":"# Convert a matrix to EuclideanSpace (columns as points)\nmatrix_data = rand(3, 100)  # 3D points, 100 samples\npoints_from_matrix = [matrix_data[:, i] for i in 1:size(matrix_data, 2)]\nX_from_matrix = EuclideanSpace(points_from_matrix)\n\n# Convert EuclideanSpace back to matrix format\nmatrix_back = as_matrix(X_from_matrix)\nprintln(\"Matrix size: \", size(matrix_back))","category":"page"},{"location":"types/#Auxiliary-Types","page":"Core Types","title":"Auxiliary Types","text":"","category":"section"},{"location":"types/#SubsetIndex","page":"Core Types","title":"SubsetIndex","text":"","category":"section"},{"location":"types/","page":"Core Types","title":"Core Types","text":"Used for representing subsets of metric spaces:","category":"page"},{"location":"types/","page":"Core Types","title":"Core Types","text":"# SubsetIndex helps track which points belong to subsets\n# This is used internally by sampling algorithms\nsubset_indices = SubsetIndex([1, 3, 5, 7, 9])  # Odd indices","category":"page"},{"location":"types/#Covering","page":"Core Types","title":"Covering","text":"","category":"section"},{"location":"types/","page":"Core Types","title":"Core Types","text":"Represents geometric coverings of metric spaces:","category":"page"},{"location":"types/","page":"Core Types","title":"Core Types","text":"# Covering structures are used in nerve computations\n# and topological constructions\ncovering = Covering(...)  # Used internally","category":"page"},{"location":"types/#Working-with-Different-Data-Types","page":"Core Types","title":"Working with Different Data Types","text":"","category":"section"},{"location":"types/#High-Dimensional-Spaces","page":"Core Types","title":"High-Dimensional Spaces","text":"","category":"section"},{"location":"types/","page":"Core Types","title":"Core Types","text":"# High-dimensional Euclidean spaces\nhigh_dim_points = [randn(50) for _ in 1:1000]  # 1000 points in 50D\nHD = EuclideanSpace(high_dim_points)\n\n# Operations remain the same regardless of dimension\ncenter = HD[1]\nnearby = ball_ids(HD, center, 2.0)","category":"page"},{"location":"types/#Custom-Objects","page":"Core Types","title":"Custom Objects","text":"","category":"section"},{"location":"types/","page":"Core Types","title":"Core Types","text":"# Define a custom type\nstruct ColoredPoint\n    position::Vector{Float64}\n    color::String\nend\n\n# Create a metric space of custom objects\ncolored_points = [\n    ColoredPoint([1.0, 2.0], \"red\"),\n    ColoredPoint([3.0, 4.0], \"blue\"),\n    ColoredPoint([5.0, 6.0], \"green\")\n]\ncolored_space = MetricSpace(colored_points)\n\n# Define distance function for colored points\nfunction colored_distance(p1::ColoredPoint, p2::ColoredPoint)\n    pos_dist = dist_euclidean(p1.position, p2.position)\n    color_penalty = (p1.color == p2.color) ? 0.0 : 1.0\n    return pos_dist + color_penalty\nend\n\n# Use with package functions\ncenter_colored = colored_space[1]\n# ball_ids(colored_space, center_colored, 2.0, colored_distance)","category":"page"},{"location":"types/#Type-Safety-and-Performance","page":"Core Types","title":"Type Safety and Performance","text":"","category":"section"},{"location":"types/#Static-Arrays","page":"Core Types","title":"Static Arrays","text":"","category":"section"},{"location":"types/","page":"Core Types","title":"Core Types","text":"EuclideanSpace uses StaticArrays.SVector internally for performance:","category":"page"},{"location":"types/","page":"Core Types","title":"Core Types","text":"# The constructor converts to SVector internally\npoints = [[1.0, 2.0], [3.0, 4.0]]\nX = EuclideanSpace(points)\n\n# But returns regular Vector for compatibility\n@assert X[1] isa Vector{Float64}","category":"page"},{"location":"types/#Memory-Layout","page":"Core Types","title":"Memory Layout","text":"","category":"section"},{"location":"types/","page":"Core Types","title":"Core Types","text":"# For maximum performance with large datasets\nfunction create_efficient_space(n_points, dimension)\n    # Pre-allocate for better memory usage\n    points = Vector{Vector{Float64}}(undef, n_points)\n    for i in 1:n_points\n        points[i] = randn(dimension)\n    end\n    return EuclideanSpace(points)\nend\n\nefficient_space = create_efficient_space(10000, 10)","category":"page"},{"location":"types/#Integration-with-Other-Packages","page":"Core Types","title":"Integration with Other Packages","text":"","category":"section"},{"location":"types/#With-Distances.jl","page":"Core Types","title":"With Distances.jl","text":"","category":"section"},{"location":"types/","page":"Core Types","title":"Core Types","text":"using Distances\n\n# EuclideanSpace works seamlessly with Distances.jl metrics\nfunction distances_jl_example(X::EuclideanSpace)\n    # Convert to matrix for Distances.jl\n    mat = as_matrix(X)\n    \n    # Use Distances.jl functions\n    euclidean_dist = Euclidean()\n    return pairwise(euclidean_dist, mat)\nend","category":"page"},{"location":"types/#With-DataFrames.jl","page":"Core Types","title":"With DataFrames.jl","text":"","category":"section"},{"location":"types/","page":"Core Types","title":"Core Types","text":"using DataFrames\n\n# Create EuclideanSpace from DataFrame\ndf = DataFrame(x=[1.0, 2.0, 3.0], y=[4.0, 5.0, 6.0])\npoints_from_df = [[row.x, row.y] for row in eachrow(df)]\nX_from_df = EuclideanSpace(points_from_df)","category":"page"},{"location":"types/#Best-Practices","page":"Core Types","title":"Best Practices","text":"","category":"section"},{"location":"types/#Choosing-the-Right-Type","page":"Core Types","title":"Choosing the Right Type","text":"","category":"section"},{"location":"types/","page":"Core Types","title":"Core Types","text":"Use EuclideanSpace for numerical point clouds in Euclidean space\nUse generic MetricSpace for non-Euclidean or custom objects\nEnsure consistent dimensions when using EuclideanSpace","category":"page"},{"location":"types/#Performance-Considerations","page":"Core Types","title":"Performance Considerations","text":"","category":"section"},{"location":"types/","page":"Core Types","title":"Core Types","text":"# Good: Pre-allocate and reuse\nfunction efficient_computation(X::EuclideanSpace)\n    n = length(X)\n    results = Vector{Float64}(undef, n)\n    \n    for i in 1:n\n        # Compute something for each point\n        results[i] = norm(X[i])\n    end\n    \n    return results\nend\n\n# Avoid: Creating temporary arrays in loops\nfunction inefficient_computation(X::EuclideanSpace)\n    results = Float64[]\n    for point in X\n        push!(results, norm(point))  # Repeated allocations\n    end\n    return results\nend","category":"page"},{"location":"types/#Type-Annotations","page":"Core Types","title":"Type Annotations","text":"","category":"section"},{"location":"types/","page":"Core Types","title":"Core Types","text":"# Good: Explicit type annotations for performance\nfunction compute_distances(X::EuclideanSpace{N,T}) where {N,T}\n    distances = Matrix{T}(undef, length(X), length(X))\n    # ... computation\n    return distances\nend","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Complete reference for all exported functions and types in MetricSpaces.jl.","category":"page"},{"location":"api/#Core-Types","page":"API Reference","title":"Core Types","text":"","category":"section"},{"location":"api/#MetricSpaces.MetricSpace","page":"API Reference","title":"MetricSpaces.MetricSpace","text":"The abstract Metric Space type is just an alias for Vector{T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#MetricSpaces.EuclideanSpace","page":"API Reference","title":"MetricSpaces.EuclideanSpace","text":"A type to model metric spaces where each element is an array of the same length.\n\n\n\n\n\n","category":"type"},{"location":"api/#MetricSpaces.as_matrix","page":"API Reference","title":"MetricSpaces.as_matrix","text":"as_matrix(X::EuclideanSpace)\n\nConvert an Euclidean space into a matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetricSpaces.SubsetIndex","page":"API Reference","title":"MetricSpaces.SubsetIndex","text":"A vector of integers, generally interpreted as  indexes of a metric space.\n\n\n\n\n\n","category":"type"},{"location":"api/#MetricSpaces.Covering","page":"API Reference","title":"MetricSpaces.Covering","text":"A covering is a vector of metric spaces, where each metric space is a subset of the original metric space X.\n\n\n\n\n\n","category":"type"},{"location":"api/#Distance-Functions","page":"API Reference","title":"Distance Functions","text":"","category":"section"},{"location":"api/#MetricSpaces.pairwise_distance","page":"API Reference","title":"MetricSpaces.pairwise_distance","text":"pairwise_distance(M::S, N::S, d) where {S <: MetricSpace{T} where {T}}\n\nCompute the pairwise distances between all elements of metric spaces M and N using the distance function d.\n\nArguments\n\nM::S: A metric space of type S, where S is a subtype of MetricSpace.\nN::S: Another metric space of the same type as M.\nd: A function that computes the distance between two elements.\n\nReturns\n\nA matrix of size length(M) Ã length(N) where the entry (i, j) contains the distance d(M[i], N[j]).\n\nNotes\n\nThe computation is parallelized across threads for improved performance.\nProgress is displayed using a progress bar.\n\n\n\n\n\npairwise_distance(M::S, N::S, d::Metric) where {S <: EuclideanSpace{N, T} where {N, T}}\n\nCompute the pairwise distances between all elements in the collections M and N using the metric d.\n\nArguments\n\nM::S: A collection of points in a Euclidean space.\nN::S: Another collection of points in the same Euclidean space as M.\nd::Metric: A metric function to compute the distance between points.\n\nReturns\n\ns::Matrix{Float64}: A matrix where the entry s[i, j] contains the distance between M[i] and N[j].\n\nNotes\n\nThe computation is parallelized across threads for efficiency.\nProgress is displayed using a progress bar.\nThe function assumes that M and N are compatible with the provided metric and space type.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetricSpaces.pairwise_distance_summary","page":"API Reference","title":"MetricSpaces.pairwise_distance_summary","text":"pairwise_distance_summary(M::S, N::S, d, summary_function = mean) where {S <: MetricSpace{T} where {T}}\n\nCompute a summary statistic of pairwise distances between each element of metric space M and all elements of metric space N using the distance function d.\n\nArguments\n\nM::S: A metric space (or collection of points) of type S.\nN::S: Another metric space (or collection of points) of type S.\nd: A function that computes the distance between two points.\nsummary_function: (Optional) A function to summarize the distances for each element of M (default is mean).\n\nReturns\n\ns: An array where each entry s[i] contains the summary statistic (e.g., mean) of the distances from the i-th element of M to all elements of N.\n\nNotes\n\nThe computation is parallelized using threads for improved performance.\nProgress is displayed using a progress bar.\n\n\n\n\n\n","category":"function"},{"location":"api/#Norm-Functions","page":"API Reference","title":"Norm Functions","text":"","category":"section"},{"location":"api/#MetricSpaces.norm","page":"API Reference","title":"MetricSpaces.norm","text":"Euclidean norm.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ball-Operations","page":"API Reference","title":"Ball Operations","text":"","category":"section"},{"location":"api/#MetricSpaces.ball","page":"API Reference","title":"MetricSpaces.ball","text":"ball(X::MetricSpace{T}, x::T, Ïµ::Number, distance=dist_euclidean) where {T}\n\nExtract the subset of points from metric space X that are within distance Ïµ from point x.\n\nThis function returns the actual points (not just indices) that form the ball  B(x, Ïµ) = {y â X : d(x, y) < Ïµ} around the center point x.\n\nArguments\n\nX::MetricSpace{T}: The metric space containing the points to search\nx::T: The center point of the ball\nÏµ::Number: The radius of the ball (must be positive)\ndistance: Distance function to use (default: dist_euclidean)\n\nReturns\n\nMetricSpace: A new metric space containing only the points within the ball\nReturns an empty metric space if no points are found within the radius\n\nExamples\n\n# Create a 1D Euclidean space\nX = EuclideanSpace(reshape([1.0, 2.0, 3.0, 4.0, 5.0], 1, 5))\n\n# Get points within distance 1.5 from [3.0]\nsubset = ball(X, [3.0], 1.5)  # Contains points [2.0, 3.0, 4.0]\n\n# Using Manhattan distance\nsubset_l1 = ball(X, [3.0], 1.5, dist_cityblock)\n\n# Check if result is empty\nresult = ball(X, [10.0], 0.1)\nisempty(result)  # true\n\nImplementation Details\n\nInternally uses ball_ids to find the relevant indices\nPreserves the metric space structure in the returned subset\nThe distance function should be compatible with the metric space type\n\nMathematical Definition\n\nFor a metric space (X, d) and point x â X, the open ball of radius Ïµ is: B(x, Ïµ) = {y â X : d(x, y) < Ïµ}\n\nSee also: ball_ids, pairwise_distance\n\n\n\n\n\n","category":"function"},{"location":"api/#MetricSpaces.ball_ids","page":"API Reference","title":"MetricSpaces.ball_ids","text":"ball_ids(X::MetricSpace{T}, x::T, Ïµ::Number, distance=dist_euclidean) where {T}\n\nFind the indices of points in metric space X that are within distance Ïµ from point x.\n\nThis function computes the ball B(x, Ïµ) = {y â X : d(x, y) < Ïµ} and returns the  indices of points in X that belong to this open ball.\n\nArguments\n\nX::MetricSpace{T}: The metric space containing the points to search\nx::T: The center point of the ball\nÏµ::Number: The radius of the ball (must be positive)\ndistance: Distance function to use (default: dist_euclidean)\n\nReturns\n\nVector{Int}: Indices of points in X that are within distance Ïµ from x\n\nExamples\n\n# Create a 1D Euclidean space\nX = EuclideanSpace(reshape([1.0, 2.0, 3.0, 4.0, 5.0], 1, 5))\n\n# Find indices of points within distance 1.5 from point [3.0]\nball_ids(X, [3.0], 1.5)  # Returns [2, 3, 4]\n\n# Using a different distance function\nball_ids(X, [3.0], 1.5, dist_cityblock)\n\nNotes\n\nUses strict inequality (d < Ïµ), so points exactly at distance Ïµ are excluded\nFor empty results, returns an empty vector\nThe distance function should be compatible with the metric space type\n\nSee also: ball, pairwise_distance\n\n\n\n\n\n","category":"function"},{"location":"api/#Neighborhood-Analysis","page":"API Reference","title":"Neighborhood Analysis","text":"","category":"section"},{"location":"api/#MetricSpaces.k_neighbors","page":"API Reference","title":"MetricSpaces.k_neighbors","text":"k_neighbors(X::MetricSpace{T}, x::T, k::Int, d=dist_euclidean) where {T}\n\nFinds the k nearest neighbors of a given point x in the metric space X.\n\nArguments\n\nX::MetricSpace{T}: The metric space containing the points.\nx::T: The query point for which the nearest neighbors are to be found.\nk::Int: The number of nearest neighbors to retrieve.\nd: The distance function to use for computing distances. Defaults to dist_euclidean.\n\nReturns\n\nA collection of the k nearest neighbors of x in X.\n\nNotes\n\nThis function internally uses k_neighbors_ids to retrieve the indices of the nearest neighbors and then returns the corresponding elements from X.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetricSpaces.distance_to_measure","page":"API Reference","title":"MetricSpaces.distance_to_measure","text":"distance_to_measure(X::S, Y::S; d=dist_euclidean, k::Integer=5, summary_function=maximum) where {S <: MetricSpace{T}}\n\nComputes a measure of distance from each point in the metric space X to the metric space Y. For each point in X, the function calculates the distances to the k nearest neighbors in Y using the provided distance function d (default is dist_euclidean). The resulting distances are summarized using the specified summary_function (default is maximum).\n\nArguments\n\nX::S: A metric space of type S containing the points to measure distances from.\nY::S: A metric space of type S containing the points to measure distances to.\nd: A distance function to compute the distance between points in X and Y. Defaults to dist_euclidean.\nk::Integer: The number of nearest neighbors in Y to consider for each point in X. Defaults to 5.\nsummary_function: A function to summarize the k nearest distances. Defaults to maximum.\n\nReturns\n\nA vector of summarized distances for each point in X.\n\nNotes\n\nThe computation is parallelized using Threads.@threads for improved performance.\nThe function assumes that the input metric spaces X and Y are compatible with the provided distance function d.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetricSpaces.excentricity","page":"API Reference","title":"MetricSpaces.excentricity","text":"excentricity(X::S, Y::S; d=dist_euclidean) where {S <: MetricSpace{T}}\n\nComputes the excentricity of the metric space X with respect to the metric space Y. The excentricity is defined as the mean of the pairwise distances between points in X and Y, using the provided distance function d (default is dist_euclidean).\n\nArguments\n\nX::S: A metric space of type S containing the points to compute excentricity for.\nY::S: A metric space of type S containing the points to compute distances to.\nd: A distance function to compute the distance between points in X and Y. Defaults to dist_euclidean.\n\nReturns\n\nA scalar value representing the excentricity of X with respect to Y.\n\nNotes\n\nThis function internally uses pairwise_distance_summary with the mean function to compute the excentricity.\n\n\n\n\n\n","category":"function"},{"location":"api/#Sampling-Methods","page":"API Reference","title":"Sampling Methods","text":"","category":"section"},{"location":"api/#MetricSpaces.epsilon_net","page":"API Reference","title":"MetricSpaces.epsilon_net","text":"epsilon_net(X::MetricSpace, Ïµ::Number; d = dist_euclidean)\n\nConstructs an epsilon-net for a given metric space X. An epsilon-net is a subset of points (landmarks) such that every point in X is within a distance Ïµ of at least one landmark.\n\nArguments\n\nX::MetricSpace: The metric space containing the points.\nÏµ::Number: The radius of the epsilon ball used to cover the points.\nd: A distance function to compute pairwise distances. Defaults to dist_euclidean.\n\nReturns\n\nlandmarks::Vector{Int}: A vector of indices representing the selected landmarks.\n\nDetails\n\nThe function iteratively selects points from X that are not yet covered by the epsilon balls of previously selected landmarks. It uses a progress meter to track the process and terminates when all points in X are covered.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetricSpaces.farthest_points_sample","page":"API Reference","title":"MetricSpaces.farthest_points_sample","text":"farthest_points_sample(X::MetricSpace, n::Integer; d = euclidean)\n\nSample n points from a metric space X using the Farthest Point Sampling (FPS) algorithm.\n\nThis method iteratively selects points that are farthest from the already selected points, resulting in a well-distributed subset of points from the original space.\n\nArguments\n\nX::MetricSpace: The input metric space to sample from\nn::Integer: Number of points to sample\nd: Distance function to use (defaults to euclidean distance)\n\nReturns\n\nA subset of n points from X that are approximately maximally distant from each other\n\nExamples\n\nX = EuclideanSpace(rand(100, 3))\nsampled_points = farthest_points_sample(X, 10)\n\nDetails\n\nThe algorithm works as follows:\n\nRandomly select the first point from X.\nFor each subsequent point, compute the distance to all previously selected points.\nSelect the point that is farthest from the previously selected points.\nRepeat until n points are selected.\n\nComplexity\n\nThe algorithm runs in O(kN) time, where k is the number of points to sample and N is the total number of points in X.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetricSpaces.random_sample","page":"API Reference","title":"MetricSpaces.random_sample","text":"random_sample(X::MetricSpace, n = 1000)\n\nRandomly sample n points from a metric space X without replacement.\n\nArguments\n\nX::MetricSpace: The metric space to sample from\nn::Integer = 1000: The number of points to sample (default: 1000)\n\nReturns\n\nVector: A vector containing min(length(X), n) randomly sampled points from X\n\nExamples\n\nX = EuclideanSpace(rand(100, 3))\nsampled_points = random_sample(X, 10)\n\n\n\n\n\n","category":"function"},{"location":"api/#Dataset-Generation","page":"API Reference","title":"Dataset Generation","text":"","category":"section"},{"location":"api/#MetricSpaces.sphere","page":"API Reference","title":"MetricSpaces.sphere","text":"sphere(num_points::Integer = 100; dim::Integer = 2, radius::Number = 1, noise::Function = zeros)\n\nGenerates a set of points uniformly distributed on the surface of a sphere in the Euclidean space.\n\nArguments\n\nnum_points::Integer=100: The number of points to generate on the sphere.\ndim::Integer=2: The dimensionality of the sphere.\nradius::Number=1: The radius of the sphere.\nnoise::Function=zeros: A function that generates noise to be added to each point. The function should accept the dimensionality dim as an argument and return a vector of the same size.\n\nReturns\n\nAn instance of EuclideanSpace containing the generated points.\n\nExample\n\nsphere(100, dim=3, radius=2.0, noise=randn)\n\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#MetricSpaces.torus","page":"API Reference","title":"MetricSpaces.torus","text":"torus(num_points::Integer = 100; r::Number = 1, R::Number = 3)\n\nArguments\n\nnum_points::Integer: the number of points.\nr::Number: the inner radius.\nR::Number: the outer radius.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetricSpaces.cube","page":"API Reference","title":"MetricSpaces.cube","text":"cube(num_points::Integer = 100; dim::Integer = 2, radius::Number = 1, noise::Function = zeros)\n\ncube(\n    num_points::Integer = 100; dim::Integer = 2, \n    radius::Number = 1, \n    noise::Function = zeros\n    )\n\nCreate a cube in R^(dim) with num_points points and radius radius.\n\nArguments\n\nnum_points::Integer: the number of points.\ndim::Integer: the dimension of the cube (that is: in which R^dim it is).\nradius::Number: the \"radius\" of the cube, that is, the distance from the center to one of its sides..\nnoise::Function: a function such that y = noise(dim) is a Vector{<:Number} with size(y) = (dim;).\n\n\n\n\n\n","category":"function"},{"location":"api/#Nerve-Construction","page":"API Reference","title":"Nerve Construction","text":"","category":"section"},{"location":"api/#MetricSpaces.nerve_1d","page":"API Reference","title":"MetricSpaces.nerve_1d","text":"nerve_1d(CX::CoveredPointCloud)\n\nGiven a covered point cloud CX, return the adjacency matrix of the 1-skeleton nerve of CX.covering.\n\n\n\n\n\n","category":"function"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"mathematical_background/#Mathematical-Background","page":"Mathematical Background","title":"Mathematical Background","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"This section provides the mathematical foundation for understanding metric spaces and the concepts implemented in MetricSpaces.jl.","category":"page"},{"location":"mathematical_background/#Metric-Spaces","page":"Mathematical Background","title":"Metric Spaces","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"A metric space is a fundamental concept in mathematics that formalizes the notion of distance between elements in a set.","category":"page"},{"location":"mathematical_background/#Definition","page":"Mathematical Background","title":"Definition","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"A metric space is a pair (X d) where:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"X\nis a non-empty set (called the underlying set)\nd X times X rightarrow mathbbR_geq 0\nis a function (called the metric or distance function)","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"The metric d must satisfy the following axioms for all x y z in X:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Non-negativity: d(x y) geq 0\nIdentity of indiscernibles: d(x y) = 0 if and only if x = y\nSymmetry: d(x y) = d(y x)\nTriangle inequality: d(x z) leq d(x y) + d(y z)","category":"page"},{"location":"mathematical_background/#Common-Distance-Functions","page":"Mathematical Background","title":"Common Distance Functions","text":"","category":"section"},{"location":"mathematical_background/#Euclidean-Distance","page":"Mathematical Background","title":"Euclidean Distance","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"For points x y in mathbbR^n:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"d_2(x y) = sqrtsum_i=1^n (x_i - y_i)^2","category":"page"},{"location":"mathematical_background/#Manhattan-Distance-(L-norm)","page":"Mathematical Background","title":"Manhattan Distance (LÂ¹ norm)","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"d_1(x y) = sum_i=1^n x_i - y_i","category":"page"},{"location":"mathematical_background/#Chebyshev-Distance-(L-norm)","page":"Mathematical Background","title":"Chebyshev Distance (Lâ norm)","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"d_infty(x y) = max_1 leq i leq n x_i - y_i","category":"page"},{"location":"mathematical_background/#Metric-Balls","page":"Mathematical Background","title":"Metric Balls","text":"","category":"section"},{"location":"mathematical_background/#Open-Balls","page":"Mathematical Background","title":"Open Balls","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Given a metric space (X d), a point x in X, and a radius r  0, the open ball centered at x with radius r is:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"B(x r) = y in X  d(x y)  r","category":"page"},{"location":"mathematical_background/#Closed-Balls","page":"Mathematical Background","title":"Closed Balls","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"The closed ball is defined as:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"overlineB(x r) = y in X  d(x y) leq r","category":"page"},{"location":"mathematical_background/#Properties","page":"Mathematical Background","title":"Properties","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Open balls are the basis for the topology of metric spaces\nEvery point in a metric space has a neighborhood system given by open balls\nBalls can be empty, finite, or infinite depending on the underlying space","category":"page"},{"location":"mathematical_background/#Covering-Theory","page":"Mathematical Background","title":"Covering Theory","text":"","category":"section"},{"location":"mathematical_background/#Îµ-nets","page":"Mathematical Background","title":"Îµ-nets","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"An Îµ-net for a metric space (X d) is a subset L subseteq X such that:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"X subseteq bigcup_x in L B(x varepsilon)","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"In other words, every point in X is within distance Îµ of some point in L.","category":"page"},{"location":"mathematical_background/#Properties-of-Îµ-nets:","page":"Mathematical Background","title":"Properties of Îµ-nets:","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Covering property: Every point is covered by at least one Îµ-ball\nEfficiency: Îµ-nets provide sparse representations of dense point sets\nApproximation: Îµ-nets preserve geometric properties up to scale Îµ","category":"page"},{"location":"mathematical_background/#Farthest-Point-Sampling","page":"Mathematical Background","title":"Farthest Point Sampling","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Farthest point sampling is a greedy algorithm that constructs a sequence of points where each new point is as far as possible from all previously selected points.","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Algorithm:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Start with an arbitrary point x_1 in X\nFor k = 2 3 ldots, choose x_k such that:\nx_k = argmax_x in X min_1 leq i leq k-1 d(x x_i)","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"This method produces well-separated point sets that are useful for:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Geometric approximation\nLandmark selection\nSparse representations","category":"page"},{"location":"mathematical_background/#Neighborhoods-and-Local-Structure","page":"Mathematical Background","title":"Neighborhoods and Local Structure","text":"","category":"section"},{"location":"mathematical_background/#k-Neighborhoods","page":"Mathematical Background","title":"k-Neighborhoods","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"For a point x in X, the k-neighborhood consists of the k nearest points to x:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"N_k(x) = y_1 y_2 ldots y_k","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"where d(x y_1) leq d(x y_2) leq cdots leq d(x y_k) and y_i neq x.","category":"page"},{"location":"mathematical_background/#Local-Density-and-Filtering","page":"Mathematical Background","title":"Local Density and Filtering","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"The distance to measure for a point x with respect to a measure mu and parameter m is:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"d_mum(x) = infr  0  mu(B(x r)) geq m","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"This concept is used in:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Outlier detection\nDensity-based clustering\nTopological data analysis","category":"page"},{"location":"mathematical_background/#Applications-in-Topological-Data-Analysis","page":"Mathematical Background","title":"Applications in Topological Data Analysis","text":"","category":"section"},{"location":"mathematical_background/#Nerve-Complexes","page":"Mathematical Background","title":"Nerve Complexes","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Given a covering mathcalU = U_alpha of a space X, the nerve is a simplicial complex where:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Vertices correspond to sets in the covering\nA k-simplex is formed by (k+1) sets with non-empty intersection","category":"page"},{"location":"mathematical_background/#Persistent-Homology","page":"Mathematical Background","title":"Persistent Homology","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Metric spaces provide the foundation for persistent homology by:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Defining filtrations through distance-based constructions\nCreating Vietoris-Rips complexes from metric data\nAnalyzing topological features across scales","category":"page"},{"location":"mathematical_background/#Implementation-Notes","page":"Mathematical Background","title":"Implementation Notes","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"MetricSpaces.jl implements these concepts with:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Efficient data structures for large-scale metric spaces\nOptimized algorithms for common operations\nFlexible distance functions supporting custom metrics\nProgress tracking for long-running computations","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"The package is designed to handle both theoretical exploration and practical applications in data analysis and computational topology.","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This guide will walk you through the basic usage of MetricSpaces.jl with practical examples.","category":"page"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"First, install the package:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"MetricSpaces\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Then load it:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using MetricSpaces","category":"page"},{"location":"getting_started/#Creating-Metric-Spaces","page":"Getting Started","title":"Creating Metric Spaces","text":"","category":"section"},{"location":"getting_started/#From-Point-Collections","page":"Getting Started","title":"From Point Collections","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The most common way to create a metric space is from a collection of points:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# 2D points\npoints_2d = [[1.0, 2.0], [3.0, 4.0], [5.0, 6.0], [1.1, 2.1], [3.2, 4.1]]\nX = EuclideanSpace(points_2d)\n\nprintln(\"Number of points: \", length(X))\nprintln(\"First point: \", X[1])","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# 3D points\npoints_3d = [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [0.5, 1.5, 2.5]]\nY = EuclideanSpace(points_3d)","category":"page"},{"location":"getting_started/#Using-Built-in-Datasets","page":"Getting Started","title":"Using Built-in Datasets","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"MetricSpaces.jl provides several built-in geometric datasets:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Generate points on a sphere\nsphere_points = sphere(100, 2)  # 100 points on a 2-sphere\nS = EuclideanSpace(sphere_points)\n\n# Generate points on a torus\ntorus_points = torus(50)  # 50 points on a torus\nT = EuclideanSpace(torus_points)\n\n# Generate points in a cube\ncube_points = cube(75, 3)  # 75 points in a 3D cube\nC = EuclideanSpace(cube_points)","category":"page"},{"location":"getting_started/#Basic-Operations","page":"Getting Started","title":"Basic Operations","text":"","category":"section"},{"location":"getting_started/#Computing-Distances","page":"Getting Started","title":"Computing Distances","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Distance between two specific points\npoint1 = X[1]\npoint2 = X[2]\ndist = dist_euclidean(point1, point2)\nprintln(\"Distance between points: \", dist)\n\n# Using different distance functions\ndist_manhattan = dist_cityblock(point1, point2)\ndist_chebyshev = dist_chebyshev(point1, point2)\n\nprintln(\"Manhattan distance: \", dist_manhattan)\nprintln(\"Chebyshev distance: \", dist_chebyshev)","category":"page"},{"location":"getting_started/#Pairwise-Distance-Matrices","page":"Getting Started","title":"Pairwise Distance Matrices","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Compute all pairwise distances\ndistances = pairwise_distance(X)\nprintln(\"Distance matrix size: \", size(distances))\n\n# Get summary statistics\nsummary = pairwise_distance_summary(X)\nprintln(\"Distance summary: \", summary)","category":"page"},{"location":"getting_started/#Working-with-Metric-Balls","page":"Getting Started","title":"Working with Metric Balls","text":"","category":"section"},{"location":"getting_started/#Finding-Neighborhoods","page":"Getting Started","title":"Finding Neighborhoods","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Find all points within distance 1.5 of the first point\ncenter = X[1]\nradius = 1.5\nnearby_ids = ball_ids(X, center, radius)\nprintln(\"Points within radius $radius: \", nearby_ids)\n\n# Get the actual points in the ball\nnearby_points = ball(X, center, radius)\nprintln(\"Number of nearby points: \", length(nearby_points))","category":"page"},{"location":"getting_started/#k-Nearest-Neighbors","page":"Getting Started","title":"k-Nearest Neighbors","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Find the 3 nearest neighbors of the first point\nk = 3\nneighbors = k_neighbors(X, X[1], k)\nprintln(\"$k nearest neighbors: \", neighbors)","category":"page"},{"location":"getting_started/#Sampling-Methods","page":"Getting Started","title":"Sampling Methods","text":"","category":"section"},{"location":"getting_started/#Îµ-net-Construction","page":"Getting Started","title":"Îµ-net Construction","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"An Îµ-net provides a sparse covering of the metric space:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Create an Îµ-net with radius 2.0\nepsilon = 2.0\nlandmarks = epsilon_net(X, epsilon)\nprintln(\"Îµ-net landmarks: \", landmarks)\nprintln(\"Number of landmarks: \", length(landmarks))\n\n# Extract the landmark points\nlandmark_points = X[landmarks]","category":"page"},{"location":"getting_started/#Farthest-Point-Sampling","page":"Getting Started","title":"Farthest Point Sampling","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Generate well-separated points using farthest point sampling:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Sample 5 points using farthest point sampling\nnum_samples = 5\nfps_indices = farthest_points_sample(X, num_samples)\nprintln(\"Farthest point sample indices: \", fps_indices)\n\n# Get the sampled points\nsampled_points = X[fps_indices]","category":"page"},{"location":"getting_started/#Random-Sampling","page":"Getting Started","title":"Random Sampling","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Random sample of 10 points\nrandom_indices = random_sample(X, 10)\nrandom_points = X[random_indices]","category":"page"},{"location":"getting_started/#Analysis-and-Filtering","page":"Getting Started","title":"Analysis and Filtering","text":"","category":"section"},{"location":"getting_started/#Distance-to-Measure","page":"Getting Started","title":"Distance to Measure","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Compute density-based measures for outlier detection:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Compute distance to measure for each point\nmeasure_distances = distance_to_measure(X, 0.1)  # 10% mass parameter\nprintln(\"Distance to measure: \", measure_distances[1:5])  # First 5 values","category":"page"},{"location":"getting_started/#Eccentricity","page":"Getting Started","title":"Eccentricity","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Measure how \"central\" each point is:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Compute eccentricity for each point\neccentricities = excentricity(X)\nprintln(\"Eccentricities: \", eccentricities[1:5])  # First 5 values\n\n# Find the most central point (minimum eccentricity)\nmost_central_idx = argmin(eccentricities)\nprintln(\"Most central point index: \", most_central_idx)","category":"page"},{"location":"getting_started/#Working-with-Different-Distance-Functions","page":"Getting Started","title":"Working with Different Distance Functions","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"You can use different distance functions throughout the package:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Using Manhattan distance for ball queries\nmanhattan_ball = ball_ids(X, center, radius, dist_cityblock)\n\n# Using Chebyshev distance for Îµ-net\nchebyshev_net = epsilon_net(X, epsilon, d=dist_chebyshev)\n\n# Custom distance function\nfunction custom_distance(x, y)\n    # Example: weighted Euclidean distance\n    weights = [2.0, 1.0]  # Different weights for each dimension\n    return sqrt(sum(weights .* (x .- y).^2))\nend\n\n# Use custom distance (where supported)\ncustom_ball = ball_ids(X, center, radius, custom_distance)","category":"page"},{"location":"getting_started/#Performance-Tips","page":"Getting Started","title":"Performance Tips","text":"","category":"section"},{"location":"getting_started/#Working-with-Large-Datasets","page":"Getting Started","title":"Working with Large Datasets","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# For large datasets, use progress tracking\nlarge_points = sphere(10000, 3)  # 10,000 points on a 3-sphere\nL = EuclideanSpace(large_points)\n\n# Operations will show progress bars automatically\nlarge_epsilon_net = epsilon_net(L, 0.5)","category":"page"},{"location":"getting_started/#Memory-Efficiency","page":"Getting Started","title":"Memory Efficiency","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# For memory efficiency with large distance matrices,\n# compute distances on-demand rather than storing the full matrix\nfunction compute_distance_on_demand(X, i, j)\n    return dist_euclidean(X[i], X[j])\nend","category":"page"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Learn about the core types for more advanced metric space constructions\nExplore distance functions for custom distance implementations\nCheck out sampling methods for advanced sampling algorithms\nSee the datasets section for more built-in geometric datasets","category":"page"},{"location":"distances/#Distance-Functions","page":"Distance Functions","title":"Distance Functions","text":"","category":"section"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"MetricSpaces.jl provides several built-in distance functions and makes it easy to work with custom distance metrics.","category":"page"},{"location":"distances/#Built-in-Distance-Functions","page":"Distance Functions","title":"Built-in Distance Functions","text":"","category":"section"},{"location":"distances/#Euclidean-Distance","page":"Distance Functions","title":"Euclidean Distance","text":"","category":"section"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"The standard Euclidean (LÂ²) distance:","category":"page"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"dist_euclidean(x, y)","category":"page"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"Mathematical Definition:","category":"page"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"d_2(x y) = sqrtsum_i=1^n (x_i - y_i)^2","category":"page"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"Example:","category":"page"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"p1 = [1.0, 2.0, 3.0]\np2 = [4.0, 5.0, 6.0]\nd = dist_euclidean(p1, p2)  # â 5.196","category":"page"},{"location":"distances/#Manhattan-Distance-(City-Block)","page":"Distance Functions","title":"Manhattan Distance (City Block)","text":"","category":"section"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"The LÂ¹ distance, also known as taxicab distance:","category":"page"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"dist_cityblock(x, y)","category":"page"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"Mathematical Definition:","category":"page"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"d_1(x y) = sum_i=1^n x_i - y_i","category":"page"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"Example:","category":"page"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"p1 = [1.0, 2.0, 3.0]\np2 = [4.0, 5.0, 6.0]\nd = dist_cityblock(p1, p2)  # = 9.0","category":"page"},{"location":"distances/#Chebyshev-Distance","page":"Distance Functions","title":"Chebyshev Distance","text":"","category":"section"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"The Lâ distance, also known as maximum distance:","category":"page"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"dist_chebyshev(x, y)","category":"page"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"Mathematical Definition:","category":"page"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"d_infty(x y) = max_1 leq i leq n x_i - y_i","category":"page"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"Example:","category":"page"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"p1 = [1.0, 2.0, 3.0]\np2 = [4.0, 5.0, 6.0]\nd = dist_chebyshev(p1, p2)  # = 3.0","category":"page"},{"location":"distances/#Using-Distance-Functions","page":"Distance Functions","title":"Using Distance Functions","text":"","category":"section"},{"location":"distances/#With-Ball-Queries","page":"Distance Functions","title":"With Ball Queries","text":"","category":"section"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"# Create a metric space\npoints = [[1.0, 2.0], [3.0, 4.0], [5.0, 6.0], [1.1, 2.1]]\nX = EuclideanSpace(points)\n\ncenter = X[1]\nradius = 2.0\n\n# Using different distance functions\neuclidean_ball = ball_ids(X, center, radius, dist_euclidean)\nmanhattan_ball = ball_ids(X, center, radius, dist_cityblock)\nchebyshev_ball = ball_ids(X, center, radius, dist_chebyshev)\n\nprintln(\"Euclidean ball: \", euclidean_ball)\nprintln(\"Manhattan ball: \", manhattan_ball)\nprintln(\"Chebyshev ball: \", chebyshev_ball)","category":"page"},{"location":"distances/#With-Sampling-Algorithms","page":"Distance Functions","title":"With Sampling Algorithms","text":"","category":"section"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"# Îµ-net with different distance functions\nepsilon = 1.5\n\neuclidean_net = epsilon_net(X, epsilon, d=dist_euclidean)\nmanhattan_net = epsilon_net(X, epsilon, d=dist_cityblock)\nchebyshev_net = epsilon_net(X, epsilon, d=dist_chebyshev)","category":"page"},{"location":"distances/#With-Pairwise-Distances","page":"Distance Functions","title":"With Pairwise Distances","text":"","category":"section"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"# Compute pairwise distance matrices\neuclidean_matrix = pairwise_distance(X, dist_euclidean)\nmanhattan_matrix = pairwise_distance(X, dist_cityblock)\nchebyshev_matrix = pairwise_distance(X, dist_chebyshev)","category":"page"},{"location":"distances/#Distance-Function-Comparison","page":"Distance Functions","title":"Distance Function Comparison","text":"","category":"section"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"Let's compare how different distance functions behave:","category":"page"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"# Create test points\ncenter = [0.0, 0.0]\ntest_points = [\n    [1.0, 0.0],   # Point 1: on x-axis\n    [0.0, 1.0],   # Point 2: on y-axis  \n    [1.0, 1.0],   # Point 3: diagonal\n    [2.0, 1.0],   # Point 4: further on x\n]\n\nX_test = EuclideanSpace([center; test_points])\n\nprintln(\"Distance comparisons from origin:\")\nprintln(\"Point\\t\\tEuclidean\\tManhattan\\tChebyshev\")\nfor (i, point) in enumerate(test_points)\n    d_euc = dist_euclidean(center, point)\n    d_man = dist_cityblock(center, point) \n    d_che = dist_chebyshev(center, point)\n    println(\"$point\\t$(round(d_euc, digits=3))\\t\\t$(round(d_man, digits=3))\\t\\t$(round(d_che, digits=3))\")\nend","category":"page"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"Output:","category":"page"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"Point           Euclidean    Manhattan    Chebyshev\n[1.0, 0.0]      1.0          1.0          1.0\n[0.0, 1.0]      1.0          1.0          1.0  \n[1.0, 1.0]      1.414        2.0          1.0\n[2.0, 1.0]      2.236        3.0          2.0","category":"page"},{"location":"distances/#Custom-Distance-Functions","page":"Distance Functions","title":"Custom Distance Functions","text":"","category":"section"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"You can define your own distance functions and use them throughout the package:","category":"page"},{"location":"distances/#Simple-Custom-Distance","page":"Distance Functions","title":"Simple Custom Distance","text":"","category":"section"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"# Weighted Euclidean distance\nfunction weighted_euclidean(x, y, weights=[1.0, 2.0])\n    diff = x .- y\n    return sqrt(sum(weights .* diff.^2))\nend\n\n# Use with ball queries\ncustom_ball = ball_ids(X, center, radius, \n                      (a, b) -> weighted_euclidean(a, b, [2.0, 1.0]))","category":"page"},{"location":"distances/#Distance-for-Custom-Types","page":"Distance Functions","title":"Distance for Custom Types","text":"","category":"section"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"# Distance function for complex numbers viewed as 2D points\nfunction complex_distance(z1::Complex, z2::Complex)\n    return abs(z1 - z2)  # Built-in complex distance\nend\n\n# Distance function for strings (Hamming distance)\nfunction hamming_distance(s1::String, s2::String)\n    if length(s1) != length(s2)\n        return Inf  # Different lengths\n    end\n    return sum(c1 != c2 for (c1, c2) in zip(s1, s2))\nend\n\n# Example usage\nstrings = [\"hello\", \"hallo\", \"hullo\", \"world\"]\nstring_space = MetricSpace(strings)\n\n# Find strings within Hamming distance 2 of \"hello\"\nsimilar_strings = ball_ids(string_space, \"hello\", 2, hamming_distance)","category":"page"},{"location":"distances/#Parametric-Distance-Functions","page":"Distance Functions","title":"Parametric Distance Functions","text":"","category":"section"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"# Minkowski distance with adjustable p\nfunction minkowski_distance(x, y, p=2)\n    if p == Inf\n        return maximum(abs.(x .- y))\n    else\n        return sum(abs.(x .- y).^p)^(1/p)\n    end\nend\n\n# Create different Minkowski distances\nl1_distance(x, y) = minkowski_distance(x, y, 1)      # Manhattan\nl2_distance(x, y) = minkowski_distance(x, y, 2)      # Euclidean  \nl3_distance(x, y) = minkowski_distance(x, y, 3)      # Cubic\nlinf_distance(x, y) = minkowski_distance(x, y, Inf)  # Chebyshev","category":"page"},{"location":"distances/#Performance-Considerations","page":"Distance Functions","title":"Performance Considerations","text":"","category":"section"},{"location":"distances/#Efficient-Distance-Computation","page":"Distance Functions","title":"Efficient Distance Computation","text":"","category":"section"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"# For repeated distance computations, avoid allocations\nfunction efficient_euclidean(x, y)\n    sum_sq = 0.0\n    for i in eachindex(x)\n        diff = x[i] - y[i]\n        sum_sq += diff * diff\n    end\n    return sqrt(sum_sq)\nend\n\n# Compare performance\nusing BenchmarkTools\n\np1 = randn(1000)\np2 = randn(1000)\n\n@btime dist_euclidean($p1, $p2)        # Built-in version\n@btime efficient_euclidean($p1, $p2)   # Optimized version","category":"page"},{"location":"distances/#Distance-Function-Properties","page":"Distance Functions","title":"Distance Function Properties","text":"","category":"section"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"When creating custom distance functions, ensure they satisfy the metric axioms:","category":"page"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"function verify_metric_axioms(distance_func, points)\n    n = length(points)\n    \n    # Test non-negativity and identity\n    for i in 1:n\n        for j in 1:n\n            d = distance_func(points[i], points[j])\n            \n            # Non-negativity\n            @assert d >= 0 \"Distance must be non-negative\"\n            \n            # Identity of indiscernibles\n            if i == j\n                @assert d == 0 \"Distance from point to itself must be zero\"\n            end\n        end\n    end\n    \n    # Test symmetry and triangle inequality\n    for i in 1:n\n        for j in 1:n\n            for k in 1:n\n                d_ij = distance_func(points[i], points[j])\n                d_ji = distance_func(points[j], points[i])\n                d_ik = distance_func(points[i], points[k])\n                d_kj = distance_func(points[k], points[j])\n                \n                # Symmetry\n                @assert abs(d_ij - d_ji) < 1e-10 \"Distance must be symmetric\"\n                \n                # Triangle inequality\n                @assert d_ij <= d_ik + d_kj + 1e-10 \"Triangle inequality must hold\"\n            end\n        end\n    end\n    \n    println(\"All metric axioms verified!\")\nend\n\n# Test built-in functions\ntest_points = [[1.0, 2.0], [3.0, 4.0], [0.0, 1.0]]\nverify_metric_axioms(dist_euclidean, test_points)","category":"page"},{"location":"distances/#Integration-with-Distances.jl","page":"Distance Functions","title":"Integration with Distances.jl","text":"","category":"section"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"For more advanced distance functions, you can integrate with the Distances.jl package:","category":"page"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"using Distances\n\n# Create Distances.jl metric objects\neuclidean_metric = Euclidean()\ncityblock_metric = Cityblock()\nchebyshev_metric = Chebyshev()\n\n# Wrapper function to use with MetricSpaces.jl\nfunction distances_jl_wrapper(metric)\n    return (x, y) -> evaluate(metric, x, y)\nend\n\n# Use with MetricSpaces.jl functions\nwrapped_euclidean = distances_jl_wrapper(euclidean_metric)\nball_with_distances_jl = ball_ids(X, center, radius, wrapped_euclidean)","category":"page"},{"location":"distances/#Advanced-Distance-Functions","page":"Distance Functions","title":"Advanced Distance Functions","text":"","category":"section"},{"location":"distances/#Mahalanobis-Distance","page":"Distance Functions","title":"Mahalanobis Distance","text":"","category":"section"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"using LinearAlgebra\n\nfunction mahalanobis_distance(x, y, Î£_inv)\n    diff = x .- y\n    return sqrt(diff' * Î£_inv * diff)\nend\n\n# Use with covariance matrix\ndata_matrix = hcat([X[i] for i in 1:length(X)]...)\nÎ£ = cov(data_matrix')\nÎ£_inv = inv(Î£)\n\nmahalanobis_func = (x, y) -> mahalanobis_distance(x, y, Î£_inv)","category":"page"},{"location":"distances/#Earth-Mover's-Distance-(for-probability-distributions)","page":"Distance Functions","title":"Earth Mover's Distance (for probability distributions)","text":"","category":"section"},{"location":"distances/","page":"Distance Functions","title":"Distance Functions","text":"# Simplified 1D Earth Mover's Distance\nfunction earth_mover_1d(p, q)\n    # Assumes p and q are probability distributions (sum to 1)\n    @assert abs(sum(p) - 1.0) < 1e-10 && abs(sum(q) - 1.0) < 1e-10\n    \n    cumsum_p = cumsum(p)\n    cumsum_q = cumsum(q)\n    \n    return sum(abs.(cumsum_p .- cumsum_q))\nend","category":"page"},{"location":"sampling/#Sampling-Methods","page":"Sampling Methods","title":"Sampling Methods","text":"","category":"section"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"MetricSpaces.jl provides several algorithms for sampling representative subsets from metric spaces. These methods are crucial for working with large datasets and creating sparse representations that preserve geometric properties.","category":"page"},{"location":"sampling/#Îµ-net-Sampling","page":"Sampling Methods","title":"Îµ-net Sampling","text":"","category":"section"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"An Îµ-net is a subset of points such that every point in the space is within distance Îµ of at least one point in the subset.","category":"page"},{"location":"sampling/#epsilon_net","page":"Sampling Methods","title":"epsilon_net","text":"","category":"section"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"epsilon_net(X::MetricSpace, Îµ::Number; d=dist_euclidean)","category":"page"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"Algorithm: Greedy selection of points that are not yet covered by existing Îµ-balls.","category":"page"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"Example:","category":"page"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"# Create a dense point cloud\npoints = [randn(2) for _ in 1:100]\nX = EuclideanSpace(points)\n\n# Generate Îµ-net with radius 0.5\nÎµ = 0.5\nlandmarks = epsilon_net(X, Îµ)\n\nprintln(\"Original space: $(length(X)) points\")\nprintln(\"Îµ-net: $(length(landmarks)) landmarks\")\nprintln(\"Compression ratio: $(round(length(landmarks)/length(X), digits=3))\")\n\n# Extract landmark points\nlandmark_points = X[landmarks]","category":"page"},{"location":"sampling/#Properties-of-Îµ-nets","page":"Sampling Methods","title":"Properties of Îµ-nets","text":"","category":"section"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"Covering: Every point is within distance Îµ of some landmark\nEfficiency: Provides sparse representation of dense point sets\nDeterministic: Greedy algorithm gives reproducible results","category":"page"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"# Verify covering property\nfunction verify_epsilon_net(X, landmarks, Îµ, distance_func=dist_euclidean)\n    uncovered_points = Int[]\n    \n    for i in 1:length(X)\n        min_dist = Inf\n        for landmark_idx in landmarks\n            dist = distance_func(X[i], X[landmark_idx])\n            min_dist = min(min_dist, dist)\n        end\n        \n        if min_dist >= Îµ\n            push!(uncovered_points, i)\n        end\n    end\n    \n    if isempty(uncovered_points)\n        println(\"â All points are covered by Îµ-net\")\n        return true\n    else\n        println(\"â Uncovered points: \", uncovered_points)\n        return false\n    end\nend\n\nverify_epsilon_net(X, landmarks, Îµ)","category":"page"},{"location":"sampling/#Farthest-Point-Sampling","page":"Sampling Methods","title":"Farthest Point Sampling","text":"","category":"section"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"Farthest Point Sampling (FPS) greedily selects points that are maximally separated from previously chosen points.","category":"page"},{"location":"sampling/#farthest_points_sample","page":"Sampling Methods","title":"farthest_points_sample","text":"","category":"section"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"farthest_points_sample(X::MetricSpace, k::Int; d=dist_euclidean, start_idx=nothing)","category":"page"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"Algorithm:","category":"page"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"Start with a random point (or specified starting point)\nIteratively select the point farthest from all previously selected points\nContinue until k points are selected","category":"page"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"Example:","category":"page"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"# Sample 10 well-separated points\nk = 10\nfps_indices = farthest_points_sample(X, k)\nfps_points = X[fps_indices]\n\nprintln(\"Selected $k points using FPS\")\nprintln(\"Indices: \", fps_indices)\n\n# Analyze separation\nfunction analyze_separation(X, indices, distance_func=dist_euclidean)\n    min_dist = Inf\n    max_dist = 0.0\n    \n    for i in 1:length(indices)\n        for j in (i+1):length(indices)\n            dist = distance_func(X[indices[i]], X[indices[j]])\n            min_dist = min(min_dist, dist)\n            max_dist = max(max_dist, dist)\n        end\n    end\n    \n    return min_dist, max_dist\nend\n\nmin_sep, max_sep = analyze_separation(X, fps_indices)\nprintln(\"Minimum separation: $(round(min_sep, digits=3))\")\nprintln(\"Maximum separation: $(round(max_sep, digits=3))\")","category":"page"},{"location":"sampling/#Controlling-the-Starting-Point","page":"Sampling Methods","title":"Controlling the Starting Point","text":"","category":"section"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"# Start FPS from a specific point\ncenter_idx = 1  # Start from first point\nfps_from_center = farthest_points_sample(X, k, start_idx=center_idx)\n\n# Compare with random start\nfps_random_start = farthest_points_sample(X, k)\n\nprintln(\"FPS from center: \", fps_from_center)\nprintln(\"FPS random start: \", fps_random_start)","category":"page"},{"location":"sampling/#Random-Sampling","page":"Sampling Methods","title":"Random Sampling","text":"","category":"section"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"Simple random sampling without replacement:","category":"page"},{"location":"sampling/#random_sample","page":"Sampling Methods","title":"random_sample","text":"","category":"section"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"random_sample(X::MetricSpace, k::Int)","category":"page"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"Example:","category":"page"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"# Random sample of 15 points\nrandom_indices = random_sample(X, 15)\nrandom_points = X[random_indices]\n\nprintln(\"Random sample indices: \", random_indices)","category":"page"},{"location":"sampling/#Reproducible-Random-Sampling","page":"Sampling Methods","title":"Reproducible Random Sampling","text":"","category":"section"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"using Random\n\n# Set seed for reproducible results\nRandom.seed!(42)\nreproducible_sample = random_sample(X, 10)\n\n# Reset and sample again - should be identical\nRandom.seed!(42)\nidentical_sample = random_sample(X, 10)\n\nprintln(\"Samples are identical: \", reproducible_sample == identical_sample)","category":"page"},{"location":"sampling/#Comparing-Sampling-Methods","page":"Sampling Methods","title":"Comparing Sampling Methods","text":"","category":"section"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"Let's compare the different sampling methods on the same dataset:","category":"page"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"# Generate test data: points on a circle with some noise\nfunction generate_noisy_circle(n_points=200, radius=1.0, noise_level=0.1)\n    angles = range(0, 2Ï, length=n_points+1)[1:end-1]  # Exclude 2Ï\n    points = Vector{Vector{Float64}}()\n    \n    for Î¸ in angles\n        # Perfect circle point\n        x = radius * cos(Î¸)\n        y = radius * sin(Î¸)\n        \n        # Add noise\n        x += randn() * noise_level\n        y += randn() * noise_level\n        \n        push!(points, [x, y])\n    end\n    \n    return EuclideanSpace(points)\nend\n\ncircle_data = generate_noisy_circle(200, 1.0, 0.05)\nk = 20  # Sample 20 points\n\n# Compare sampling methods\neps_net_result = epsilon_net(circle_data, 0.3)\nfps_result = farthest_points_sample(circle_data, k)\nrandom_result = random_sample(circle_data, k)\n\nprintln(\"Sampling method comparison:\")\nprintln(\"Îµ-net (Îµ=0.3): $(length(eps_net_result)) points\")\nprintln(\"FPS (k=$k): $(length(fps_result)) points\")\nprintln(\"Random (k=$k): $(length(random_result)) points\")","category":"page"},{"location":"sampling/#Advanced-Sampling-Techniques","page":"Sampling Methods","title":"Advanced Sampling Techniques","text":"","category":"section"},{"location":"sampling/#Adaptive-Sampling","page":"Sampling Methods","title":"Adaptive Sampling","text":"","category":"section"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"Combine different sampling methods based on local density:","category":"page"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"function adaptive_sample(X::EuclideanSpace, target_size::Int, density_threshold=2.0)\n    # Start with FPS for good coverage\n    initial_sample = farthest_points_sample(X, target_size Ã· 2)\n    \n    # Identify high-density regions\n    remaining_points = setdiff(1:length(X), initial_sample)\n    high_density_regions = Int[]\n    \n    for idx in remaining_points\n        neighbors = ball_ids(X, X[idx], 0.2)  # Small radius\n        if length(neighbors) > density_threshold\n            push!(high_density_regions, idx)\n        end\n    end\n    \n    # Add random samples from high-density regions\n    if length(high_density_regions) > 0\n        additional_count = target_size - length(initial_sample)\n        if additional_count > 0\n            additional_indices = high_density_regions[randperm(length(high_density_regions))[1:min(additional_count, length(high_density_regions))]]\n            return vcat(initial_sample, additional_indices)\n        end\n    end\n    \n    return initial_sample\nend\n\nadaptive_result = adaptive_sample(circle_data, 25)\nprintln(\"Adaptive sampling: $(length(adaptive_result)) points\")","category":"page"},{"location":"sampling/#Stratified-Sampling","page":"Sampling Methods","title":"Stratified Sampling","text":"","category":"section"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"Sample uniformly from different regions:","category":"page"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"function stratified_sample(X::EuclideanSpace, n_strata::Int, points_per_stratum::Int)\n    # Simple 2D stratification by quadrants\n    strata = [Int[] for _ in 1:n_strata]\n    \n    # Assign points to strata based on their coordinates\n    for i in 1:length(X)\n        point = X[i]\n        # Simple hash-based assignment\n        stratum = (hash(point) % n_strata) + 1\n        push!(strata[stratum], i)\n    end\n    \n    # Sample from each stratum\n    sampled_indices = Int[]\n    for stratum in strata\n        if length(stratum) >= points_per_stratum\n            sampled = stratum[randperm(length(stratum))[1:points_per_stratum]]\n            append!(sampled_indices, sampled)\n        else\n            append!(sampled_indices, stratum)  # Take all if stratum is small\n        end\n    end\n    \n    return sampled_indices\nend\n\nstratified_result = stratified_sample(circle_data, 4, 5)\nprintln(\"Stratified sampling: $(length(stratified_result)) points\")","category":"page"},{"location":"sampling/#Performance-Analysis","page":"Sampling Methods","title":"Performance Analysis","text":"","category":"section"},{"location":"sampling/#Timing-Comparisons","page":"Sampling Methods","title":"Timing Comparisons","text":"","category":"section"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"using BenchmarkTools\n\n# Large dataset for performance testing\nlarge_data = EuclideanSpace([randn(10) for _ in 1:1000])\nk = 50\n\nprintln(\"Performance comparison on 1000 points in 10D:\")\n\n# Benchmark different methods\nprintln(\"Random sampling:\")\n@btime random_sample($large_data, $k)\n\nprintln(\"Farthest point sampling:\")\n@btime farthest_points_sample($large_data, $k)\n\nprintln(\"Îµ-net sampling:\")\n@btime epsilon_net($large_data, 1.0)","category":"page"},{"location":"sampling/#Memory-Usage","page":"Sampling Methods","title":"Memory Usage","text":"","category":"section"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"function memory_usage_analysis(X::EuclideanSpace)\n    n = length(X)\n    point_dim = length(X[1])\n    \n    # Estimate memory usage for different operations\n    point_size = sizeof(X[1])\n    total_points_memory = n * point_size\n    \n    # Distance matrix would require O(nÂ²) memory\n    distance_matrix_memory = n^2 * sizeof(Float64)\n    \n    println(\"Memory analysis for $(n) points in $(point_dim)D:\")\n    println(\"Points storage: $(round(total_points_memory/1024, digits=2)) KB\")\n    println(\"Full distance matrix: $(round(distance_matrix_memory/1024/1024, digits=2)) MB\")\n    \n    # Sampling reduces memory requirements\n    sample_fraction = 0.1\n    sampled_memory = (n * sample_fraction)^2 * sizeof(Float64)\n    println(\"10% sample distance matrix: $(round(sampled_memory/1024, digits=2)) KB\")\nend\n\nmemory_usage_analysis(large_data)","category":"page"},{"location":"sampling/#Applications","page":"Sampling Methods","title":"Applications","text":"","category":"section"},{"location":"sampling/#Landmark-Based-Approximation","page":"Sampling Methods","title":"Landmark-Based Approximation","text":"","category":"section"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"Use sampled points as landmarks for approximating distances:","category":"page"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"function landmark_approximation(X::EuclideanSpace, query_point, landmarks_indices, distance_func=dist_euclidean)\n    # Approximate distance from query point to all points in X\n    # using distances to landmarks\n    \n    landmark_distances = [distance_func(query_point, X[idx]) for idx in landmarks_indices]\n    approximations = Float64[]\n    \n    for i in 1:length(X)\n        # Use triangle inequality for approximation\n        min_approx = Inf\n        for (j, landmark_idx) in enumerate(landmarks_indices)\n            # Triangle inequality: |d(q,x) - d(q,l)| â¤ d(x,l)\n            landmark_to_point = distance_func(X[landmark_idx], X[i])\n            approx = abs(landmark_distances[j] - landmark_to_point)\n            min_approx = min(min_approx, approx)\n        end\n        push!(approximations, min_approx)\n    end\n    \n    return approximations\nend\n\n# Example usage\nlandmarks = farthest_points_sample(X, 5)\nquery = [0.5, 0.5]\napproximations = landmark_approximation(X, query, landmarks)","category":"page"},{"location":"sampling/#Multi-Scale-Sampling","page":"Sampling Methods","title":"Multi-Scale Sampling","text":"","category":"section"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"Create hierarchical samples at different scales:","category":"page"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"function multiscale_sampling(X::EuclideanSpace, scales=[1.0, 0.5, 0.25])\n    samples = Dict{Float64, Vector{Int}}()\n    \n    for scale in scales\n        # Use Îµ-net with scale as radius\n        sample_indices = epsilon_net(X, scale)\n        samples[scale] = sample_indices\n        println(\"Scale $scale: $(length(sample_indices)) points\")\n    end\n    \n    return samples\nend\n\nmultiscale_result = multiscale_sampling(circle_data, [0.5, 0.3, 0.1])","category":"page"},{"location":"sampling/#Best-Practices","page":"Sampling Methods","title":"Best Practices","text":"","category":"section"},{"location":"sampling/#Choosing-Sample-Size","page":"Sampling Methods","title":"Choosing Sample Size","text":"","category":"section"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"function estimate_sample_size(X::EuclideanSpace, target_error=0.1)\n    # Rough heuristic: sample size based on intrinsic dimension\n    n = length(X)\n    dim = length(X[1])\n    \n    # More points needed for higher dimensions\n    base_sample = max(10, Int(ceil(dim * 5)))\n    \n    # Scale with dataset size (logarithmically)\n    size_factor = log(n) / log(100)  # Normalized to log(100)\n    \n    estimated_size = Int(ceil(base_sample * size_factor))\n    \n    println(\"Estimated sample size for $n points in $(dim)D: $estimated_size\")\n    return min(estimated_size, n Ã· 2)  # Don't sample more than half\nend\n\nrecommended_size = estimate_sample_size(circle_data)\noptimal_sample = farthest_points_sample(circle_data, recommended_size)","category":"page"},{"location":"sampling/#Quality-Assessment","page":"Sampling Methods","title":"Quality Assessment","text":"","category":"section"},{"location":"sampling/","page":"Sampling Methods","title":"Sampling Methods","text":"function assess_sample_quality(X::EuclideanSpace, sample_indices, distance_func=dist_euclidean)\n    sample_points = X[sample_indices]\n    \n    # Coverage: average distance to nearest sample point\n    coverage_distances = Float64[]\n    for i in 1:length(X)\n        min_dist = minimum(distance_func(X[i], sample_points[j]) for j in 1:length(sample_points))\n        push!(coverage_distances, min_dist)\n    end\n    \n    avg_coverage = mean(coverage_distances)\n    max_coverage = maximum(coverage_distances)\n    \n    # Separation: minimum distance between sample points\n    min_separation = Inf\n    for i in 1:length(sample_points)\n        for j in (i+1):length(sample_points)\n            dist = distance_func(sample_points[i], sample_points[j])\n            min_separation = min(min_separation, dist)\n        end\n    end\n    \n    println(\"Sample quality assessment:\")\n    println(\"  Average coverage distance: $(round(avg_coverage, digits=4))\")\n    println(\"  Maximum coverage distance: $(round(max_coverage, digits=4))\")\n    println(\"  Minimum separation: $(round(min_separation, digits=4))\")\n    \n    return (coverage=avg_coverage, max_coverage=max_coverage, separation=min_separation)\nend\n\n# Compare quality of different sampling methods\nprintln(\"FPS quality:\")\nfps_quality = assess_sample_quality(circle_data, fps_result)\n\nprintln(\"\\nRandom sampling quality:\")\nrandom_quality = assess_sample_quality(circle_data, random_result)","category":"page"},{"location":"#MetricSpaces.jl","page":"Home","title":"MetricSpaces.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for working with metric spaces in Topological Data Analysis (TDA), providing efficient data structures and algorithms for metric space operations.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MetricSpaces.jl provides a comprehensive toolkit for working with metric spaces, including:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Core Types: Flexible metric space representations\nDistance Functions: Various distance metrics (Euclidean, Manhattan, Chebyshev)\nMetric Balls: Efficient neighborhood queries\nSampling Methods: Îµ-nets, farthest point sampling, random sampling\nDatasets: Built-in geometric datasets (spheres, tori, cubes)\nAnalysis Tools: Neighborhood analysis, filtering, and nerve computations","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"MetricSpaces\")","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using MetricSpaces\n\n# Create a metric space from 2D points\npoints = [[1.0, 2.0], [3.0, 4.0], [5.0, 6.0], [1.1, 2.1]]\nX = EuclideanSpace(points)\n\n# Find points within distance 1.0 of the first point\ncenter = X[1]\nnearby_indices = ball_ids(X, center, 1.0)\n\n# Compute pairwise distances\ndistances = pairwise_distance(X)\n\n# Generate an Îµ-net covering\nlandmarks = epsilon_net(X, 2.0)","category":"page"},{"location":"#Mathematical-Foundation","page":"Home","title":"Mathematical Foundation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is built on solid mathematical foundations from metric geometry and topological data analysis. The core concepts include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Metric Spaces: Sets equipped with distance functions satisfying the metric axioms\nMetric Balls: Fundamental neighborhoods in metric spaces\nCovering Properties: Îµ-nets and other geometric covering constructions\nSampling Theory: Geometric sampling methods for large metric spaces","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"#**Efficient-Algorithms**","page":"Home","title":"ð¯ Efficient Algorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Optimized implementations of fundamental metric space operations with progress tracking for large datasets.","category":"page"},{"location":"#**Rich-Dataset-Support**","page":"Home","title":"ð Rich Dataset Support","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Built-in generators for common geometric datasets used in TDA research and education.","category":"page"},{"location":"#**Flexible-Distance-Functions**","page":"Home","title":"ð§ Flexible Distance Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Support for multiple distance metrics with easy extensibility for custom distance functions.","category":"page"},{"location":"#**Analysis-Tools**","page":"Home","title":"ð Analysis Tools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Comprehensive tools for neighborhood analysis, filtering, and geometric property computation.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Continue to the mathematical background to understand the theory behind metric spaces, or jump to the getting started guide for practical examples.","category":"page"},{"location":"balls/#Metric-Balls","page":"Metric Balls","title":"Metric Balls","text":"","category":"section"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"Metric balls are fundamental geometric objects in metric spaces that represent neighborhoods around points. MetricSpaces.jl provides efficient functions for working with balls and performing neighborhood queries.","category":"page"},{"location":"balls/#Basic-Concepts","page":"Metric Balls","title":"Basic Concepts","text":"","category":"section"},{"location":"balls/#Open-Balls","page":"Metric Balls","title":"Open Balls","text":"","category":"section"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"An open ball B(x r) centered at point x with radius r is the set of all points within distance r of x:","category":"page"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"B(x r) = y in X  d(x y)  r","category":"page"},{"location":"balls/#Closed-Balls","page":"Metric Balls","title":"Closed Balls","text":"","category":"section"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"A closed ball overlineB(x r) includes points exactly at distance r:","category":"page"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"overlineB(x r) = y in X  d(x y) leq r","category":"page"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"Note: MetricSpaces.jl implements open balls by default (using strict inequality).","category":"page"},{"location":"balls/#Ball-Functions","page":"Metric Balls","title":"Ball Functions","text":"","category":"section"},{"location":"balls/#ball_ids-Get-Indices-in-Ball","page":"Metric Balls","title":"ball_ids - Get Indices in Ball","text":"","category":"section"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"Find the indices of points within a ball:","category":"page"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"ball_ids(X::MetricSpace, center, radius, distance_function=dist_euclidean)","category":"page"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"Example:","category":"page"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"# Create a 2D metric space\npoints = [[0.0, 0.0], [1.0, 0.0], [0.0, 1.0], [1.0, 1.0], [2.0, 2.0]]\nX = EuclideanSpace(points)\n\n# Find points within distance 1.5 of origin\ncenter = [0.0, 0.0]\nradius = 1.5\nindices = ball_ids(X, center, radius)\nprintln(\"Points in ball: \", indices)  # [1, 2, 3, 4]","category":"page"},{"location":"balls/#ball-Get-Points-in-Ball","page":"Metric Balls","title":"ball - Get Points in Ball","text":"","category":"section"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"Retrieve the actual points (not just indices) within a ball:","category":"page"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"ball(X::MetricSpace, center, radius, distance_function=dist_euclidean)","category":"page"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"Example:","category":"page"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"# Get the actual points in the ball\npoints_in_ball = ball(X, center, radius)\nprintln(\"Points in ball:\")\nfor (i, point) in enumerate(points_in_ball)\n    println(\"  $i: $point\")\nend","category":"page"},{"location":"balls/#Working-with-Different-Distance-Functions","page":"Metric Balls","title":"Working with Different Distance Functions","text":"","category":"section"},{"location":"balls/#Euclidean-Balls","page":"Metric Balls","title":"Euclidean Balls","text":"","category":"section"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"# Standard Euclidean ball\neuclidean_ball = ball_ids(X, [0.0, 0.0], 1.5, dist_euclidean)","category":"page"},{"location":"balls/#Manhattan-Balls","page":"Metric Balls","title":"Manhattan Balls","text":"","category":"section"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"# Manhattan distance creates diamond-shaped \"balls\"\nmanhattan_ball = ball_ids(X, [0.0, 0.0], 2.0, dist_cityblock)","category":"page"},{"location":"balls/#Chebyshev-Balls","page":"Metric Balls","title":"Chebyshev Balls","text":"","category":"section"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"# Chebyshev distance creates square-shaped \"balls\"  \nchebyshev_ball = ball_ids(X, [0.0, 0.0], 1.0, dist_chebyshev)","category":"page"},{"location":"balls/#Visual-Comparison-of-Ball-Shapes","page":"Metric Balls","title":"Visual Comparison of Ball Shapes","text":"","category":"section"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"Let's create a comprehensive example showing how different distance functions create different ball shapes:","category":"page"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"# Create a grid of points for visualization\nfunction create_grid_points(range_x, range_y, step=0.5)\n    points = Vector{Vector{Float64}}()\n    for x in range_x[1]:step:range_x[2]\n        for y in range_y[1]:step:range_y[2]\n            push!(points, [x, y])\n        end\n    end\n    return EuclideanSpace(points)\nend\n\n# Create a 5x5 grid centered at origin\ngrid = create_grid_points((-2, 2), (-2, 2), 0.5)\ncenter = [0.0, 0.0]\nradius = 1.0\n\n# Compare different ball shapes\neuclidean_indices = ball_ids(grid, center, radius, dist_euclidean)\nmanhattan_indices = ball_ids(grid, center, radius, dist_cityblock)\nchebyshev_indices = ball_ids(grid, center, radius, dist_chebyshev)\n\nprintln(\"Ball comparison with radius $radius:\")\nprintln(\"Euclidean ball contains $(length(euclidean_indices)) points\")\nprintln(\"Manhattan ball contains $(length(manhattan_indices)) points\") \nprintln(\"Chebyshev ball contains $(length(chebyshev_indices)) points\")\n\n# Get the actual points for each ball type\neuclidean_points = ball(grid, center, radius, dist_euclidean)\nmanhattan_points = ball(grid, center, radius, dist_cityblock)\nchebyshev_points = ball(grid, center, radius, dist_chebyshev)","category":"page"},{"location":"balls/#Advanced-Ball-Operations","page":"Metric Balls","title":"Advanced Ball Operations","text":"","category":"section"},{"location":"balls/#Multiple-Centers","page":"Metric Balls","title":"Multiple Centers","text":"","category":"section"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"Find points within balls around multiple centers:","category":"page"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"# Multiple centers\ncenters = [[0.0, 0.0], [2.0, 2.0], [-1.0, 1.0]]\nradius = 1.0\n\n# Find points in union of all balls\nunion_points = Set{Int}()\nfor center in centers\n    ball_indices = ball_ids(X, center, radius)\n    union!(union_points, ball_indices)\nend\n\nprintln(\"Points in union of balls: \", sort(collect(union_points)))","category":"page"},{"location":"balls/#Nested-Balls","page":"Metric Balls","title":"Nested Balls","text":"","category":"section"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"Analyze the structure of nested balls:","category":"page"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"# Create nested balls with increasing radii\ncenter = [0.0, 0.0]\nradii = [0.5, 1.0, 1.5, 2.0, 2.5]\n\nprintln(\"Nested ball structure:\")\nfor r in radii\n    ball_indices = ball_ids(X, center, r)\n    println(\"Radius $r: $(length(ball_indices)) points\")\nend","category":"page"},{"location":"balls/#Ball-Intersection","page":"Metric Balls","title":"Ball Intersection","text":"","category":"section"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"Find points that are in the intersection of multiple balls:","category":"page"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"# Two centers with overlapping balls\ncenter1 = [0.0, 0.0]\ncenter2 = [1.0, 0.0]\nradius = 1.0\n\nball1_indices = Set(ball_ids(X, center1, radius))\nball2_indices = Set(ball_ids(X, center2, radius))\n\n# Intersection\nintersection_indices = intersect(ball1_indices, ball2_indices)\nprintln(\"Points in intersection: \", sort(collect(intersection_indices)))\n\n# Union  \nunion_indices = union(ball1_indices, ball2_indices)\nprintln(\"Points in union: \", sort(collect(union_indices)))\n\n# Difference\ndifference_indices = setdiff(ball1_indices, ball2_indices)\nprintln(\"Points in ball1 but not ball2: \", sort(collect(difference_indices)))","category":"page"},{"location":"balls/#Performance-Optimization","page":"Metric Balls","title":"Performance Optimization","text":"","category":"section"},{"location":"balls/#Efficient-Ball-Queries","page":"Metric Balls","title":"Efficient Ball Queries","text":"","category":"section"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"For repeated ball queries, consider pre-computing distance matrices:","category":"page"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"# For small spaces, pre-compute distance matrix\nfunction precompute_distances(X::EuclideanSpace, distance_func=dist_euclidean)\n    n = length(X)\n    distances = Matrix{Float64}(undef, n, n)\n    \n    for i in 1:n\n        for j in 1:n\n            distances[i, j] = distance_func(X[i], X[j])\n        end\n    end\n    \n    return distances\nend\n\n# Fast ball queries using pre-computed distances\nfunction fast_ball_ids(distances::Matrix, center_idx::Int, radius::Float64)\n    return findall(d -> d < radius, distances[center_idx, :])\nend\n\n# Example usage\ndistances = precompute_distances(X)\ncenter_idx = 1\nfast_ball = fast_ball_ids(distances, center_idx, 1.5)","category":"page"},{"location":"balls/#Large-Scale-Ball-Queries","page":"Metric Balls","title":"Large-Scale Ball Queries","text":"","category":"section"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"For large datasets, use spatial data structures or approximate methods:","category":"page"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"# Approximate ball query for large datasets\nfunction approximate_ball_ids(X::EuclideanSpace, center, radius, sample_fraction=0.1)\n    n = length(X)\n    sample_size = max(1, Int(floor(n * sample_fraction)))\n    \n    # Random sample for approximate query\n    sample_indices = randperm(n)[1:sample_size]\n    \n    ball_indices = Int[]\n    for idx in sample_indices\n        if dist_euclidean(X[idx], center) < radius\n            push!(ball_indices, idx)\n        end\n    end\n    \n    return ball_indices\nend","category":"page"},{"location":"balls/#Applications","page":"Metric Balls","title":"Applications","text":"","category":"section"},{"location":"balls/#Outlier-Detection","page":"Metric Balls","title":"Outlier Detection","text":"","category":"section"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"Use ball queries to identify outliers:","category":"page"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"function detect_outliers(X::EuclideanSpace, min_neighbors=2, radius=1.0)\n    outliers = Int[]\n    \n    for i in 1:length(X)\n        neighbors = ball_ids(X, X[i], radius)\n        # Remove the point itself from neighbor count\n        neighbor_count = length(neighbors) - 1\n        \n        if neighbor_count < min_neighbors\n            push!(outliers, i)\n        end\n    end\n    \n    return outliers\nend\n\n# Find outliers in the dataset\noutlier_indices = detect_outliers(X, 1, 1.0)\nprintln(\"Outlier indices: \", outlier_indices)","category":"page"},{"location":"balls/#Local-Density-Estimation","page":"Metric Balls","title":"Local Density Estimation","text":"","category":"section"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"Estimate local density using ball counts:","category":"page"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"function local_density(X::EuclideanSpace, radius=1.0)\n    densities = Float64[]\n    \n    for i in 1:length(X)\n        ball_indices = ball_ids(X, X[i], radius)\n        # Density = number of neighbors / ball volume\n        # For 2D: ball area = Ï * rÂ²\n        density = length(ball_indices) / (Ï * radius^2)\n        push!(densities, density)\n    end\n    \n    return densities\nend\n\ndensities = local_density(X, 1.0)\nprintln(\"Local densities: \", densities)","category":"page"},{"location":"balls/#Clustering","page":"Metric Balls","title":"Clustering","text":"","category":"section"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"Use balls for simple clustering:","category":"page"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"function ball_clustering(X::EuclideanSpace, radius=1.0)\n    n = length(X)\n    visited = falses(n)\n    clusters = Vector{Vector{Int}}()\n    \n    for i in 1:n\n        if !visited[i]\n            # Start new cluster\n            cluster = ball_ids(X, X[i], radius)\n            \n            # Mark all points in cluster as visited\n            for idx in cluster\n                visited[idx] = true\n            end\n            \n            push!(clusters, cluster)\n        end\n    end\n    \n    return clusters\nend\n\nclusters = ball_clustering(X, 1.5)\nprintln(\"Found $(length(clusters)) clusters:\")\nfor (i, cluster) in enumerate(clusters)\n    println(\"  Cluster $i: $cluster\")\nend","category":"page"},{"location":"balls/#Edge-Cases-and-Considerations","page":"Metric Balls","title":"Edge Cases and Considerations","text":"","category":"section"},{"location":"balls/#Empty-Balls","page":"Metric Balls","title":"Empty Balls","text":"","category":"section"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"# Very small radius might result in empty balls\ntiny_radius = 1e-10\ntiny_ball = ball_ids(X, [0.0, 0.0], tiny_radius)\nprintln(\"Tiny ball contains: \", length(tiny_ball), \" points\")","category":"page"},{"location":"balls/#Large-Balls","page":"Metric Balls","title":"Large Balls","text":"","category":"section"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"# Very large radius includes all points\nlarge_radius = 1000.0\nlarge_ball = ball_ids(X, [0.0, 0.0], large_radius)\nprintln(\"Large ball contains: \", length(large_ball), \" points (total: $(length(X)))\")","category":"page"},{"location":"balls/#Boundary-Effects","page":"Metric Balls","title":"Boundary Effects","text":"","category":"section"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"When working with finite point sets, be aware that balls near the boundary might have fewer neighbors than expected:","category":"page"},{"location":"balls/","page":"Metric Balls","title":"Metric Balls","text":"# Points on the boundary of the point cloud\nboundary_point = X[end]  # Likely on boundary\ninterior_point = X[1]    # Likely more central\n\nboundary_ball = ball_ids(X, boundary_point, 1.0)\ninterior_ball = ball_ids(X, interior_point, 1.0)\n\nprintln(\"Boundary point has $(length(boundary_ball)) neighbors\")\nprintln(\"Interior point has $(length(interior_ball)) neighbors\")","category":"page"},{"location":"datasets/#Datasets","page":"Datasets","title":"Datasets","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"MetricSpaces.jl provides several built-in geometric datasets commonly used in topological data analysis and computational geometry research.","category":"page"},{"location":"datasets/#Geometric-Datasets","page":"Datasets","title":"Geometric Datasets","text":"","category":"section"},{"location":"datasets/#Sphere","page":"Datasets","title":"Sphere","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"Generate points on the surface of an n-dimensional sphere.","category":"page"},{"location":"datasets/#sphere(n_points,-dimension)","page":"Datasets","title":"sphere(n_points, dimension)","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"sphere(n_points::Int, dimension::Int)","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"Parameters:","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"n_points: Number of points to generate\ndimension: Dimension of the sphere (2 for circle, 3 for standard sphere, etc.)","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"Mathematical Background: Points are generated on the unit sphere S^n-1 subset mathbbR^n:","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"S^n-1 = x in mathbbR^n  x_2 = 1","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"Example:","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"# Generate 100 points on a 2-sphere (surface of a ball in 3D)\nsphere_points = sphere(100, 3)\nS = EuclideanSpace(sphere_points)\n\nprintln(\"Generated $(length(S)) points on a 2-sphere\")\nprintln(\"First point: $(S[1])\")\nprintln(\"Distance from origin: $(norm(S[1]))\")  # Should be â 1.0\n\n# Verify points are on unit sphere\ndistances_from_origin = [norm(point) for point in S]\nprintln(\"All points on unit sphere: \", all(abs.(distances_from_origin .- 1.0) .< 1e-10))","category":"page"},{"location":"datasets/#Applications-of-Sphere-Data","page":"Datasets","title":"Applications of Sphere Data","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"Clustering on Spheres:","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"# Spherical data often requires specialized clustering\nfunction spherical_kmeans_demo(sphere_data, k=3)\n    # Simple spherical k-means (not implemented in full here)\n    # In practice, use specialized spherical clustering algorithms\n    \n    # For demonstration, use standard k-means on sphere data\n    centers = sphere_data[randperm(length(sphere_data))[1:k]]\n    \n    println(\"Spherical clustering with $k centers:\")\n    for (i, center) in enumerate(centers)\n        println(\"  Center $i: $(round.(center, digits=3))\")\n    end\n    \n    return centers\nend\n\nsphere_centers = spherical_kmeans_demo(sphere_points, 4)","category":"page"},{"location":"datasets/#Torus","page":"Datasets","title":"Torus","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"Generate points on the surface of a torus.","category":"page"},{"location":"datasets/#torus(n_points)","page":"Datasets","title":"torus(n_points)","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"torus(n_points::Int)","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"Mathematical Background: A torus is parameterized by two angles (Î¸ Ï):","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"beginalign\nx = (R + rcos Ï) cos Î¸ \ny = (R + rcos Ï) sin Î¸ \nz = r sin Ï\nendalign","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"where R is the major radius and r is the minor radius.","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"Example:","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"# Generate 200 points on a torus\ntorus_points = torus(200)\nT = EuclideanSpace(torus_points)\n\nprintln(\"Generated $(length(T)) points on a torus\")\nprintln(\"Sample points:\")\nfor i in 1:3\n    println(\"  Point $i: $(round.(T[i], digits=3))\")\nend\n\n# Analyze torus structure\nfunction analyze_torus_structure(torus_data)\n    # Distance from z-axis (should reveal torus structure)\n    xy_distances = [sqrt(point[1]^2 + point[2]^2) for point in torus_data]\n    z_coordinates = [point[3] for point in torus_data]\n    \n    println(\"Torus analysis:\")\n    println(\"  XY distances - min: $(round(minimum(xy_distances), digits=3)), max: $(round(maximum(xy_distances), digits=3))\")\n    println(\"  Z coordinates - min: $(round(minimum(z_coordinates), digits=3)), max: $(round(maximum(z_coordinates), digits=3))\")\n    \n    return xy_distances, z_coordinates\nend\n\nxy_dists, z_coords = analyze_torus_structure(torus_points)","category":"page"},{"location":"datasets/#Applications-of-Torus-Data","page":"Datasets","title":"Applications of Torus Data","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"Persistent Homology:","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"# Torus data is excellent for testing persistent homology algorithms\n# The torus has known topology: H_0 = â¤, H_1 = â¤Â², H_2 = â¤\n\nfunction torus_homology_demo(torus_data)\n    # Compute some basic topological features\n    # (This would typically use a specialized TDA library)\n    \n    # For demonstration: analyze 1-dimensional holes using simple graph methods\n    using Graphs\n    \n    # Build neighborhood graph\n    g = SimpleGraph(length(torus_data))\n    threshold = 0.5  # Connection threshold\n    \n    for i in 1:length(torus_data)\n        for j in (i+1):length(torus_data)\n            if dist_euclidean(torus_data[i], torus_data[j]) < threshold\n                add_edge!(g, i, j)\n            end\n        end\n    end\n    \n    components = connected_components(g)\n    println(\"Graph analysis at threshold $threshold:\")\n    println(\"  Connected components: $(length(components))\")\n    println(\"  Edges: $(ne(g))\")\n    \n    return g\nend\n\ntorus_graph = torus_homology_demo(torus_points)","category":"page"},{"location":"datasets/#Cube","page":"Datasets","title":"Cube","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"Generate points uniformly distributed in an n-dimensional cube.","category":"page"},{"location":"datasets/#cube(n_points,-dimension)","page":"Datasets","title":"cube(n_points, dimension)","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"cube(n_points::Int, dimension::Int)","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"Mathematical Background: Points are generated uniformly in the unit cube 01^n:","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"x in mathbbR^n  0 leq x_i leq 1 text for all  i","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"Example:","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"# Generate 150 points in a 3D cube\ncube_points = cube(150, 3)\nC = EuclideanSpace(cube_points)\n\nprintln(\"Generated $(length(C)) points in a 3D cube\")\n\n# Verify points are in unit cube\nfunction verify_cube_bounds(cube_data, dimension)\n    all_in_bounds = true\n    for point in cube_data\n        for coord in point\n            if coord < 0 || coord > 1\n                all_in_bounds = false\n                break\n            end\n        end\n        if !all_in_bounds\n            break\n        end\n    end\n    \n    println(\"All points in unit cube: $all_in_bounds\")\n    return all_in_bounds\nend\n\nverify_cube_bounds(cube_points, 3)\n\n# Analyze cube properties\nfunction analyze_cube_distribution(cube_data)\n    dimension = length(cube_data[1])\n    \n    println(\"Cube distribution analysis:\")\n    for dim in 1:dimension\n        coords = [point[dim] for point in cube_data]\n        println(\"  Dimension $dim: mean=$(round(mean(coords), digits=3)), std=$(round(std(coords), digits=3))\")\n    end\n    \n    # Check for uniform distribution (should be close to uniform)\n    return [mean([point[dim] for point in cube_data]) for dim in 1:dimension]\nend\n\nmeans = analyze_cube_distribution(cube_points)","category":"page"},{"location":"datasets/#Applications-of-Cube-Data","page":"Datasets","title":"Applications of Cube Data","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"Curse of Dimensionality Studies:","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"function curse_of_dimensionality_demo(dimensions=[2, 5, 10, 20])\n    println(\"Curse of dimensionality demonstration:\")\n    \n    for dim in dimensions\n        # Generate points in high-dimensional cube\n        n_points = 1000\n        points = cube(n_points, dim)\n        \n        # Compute pairwise distances\n        distances = Float64[]\n        for i in 1:min(100, n_points)  # Sample for efficiency\n            for j in (i+1):min(100, n_points)\n                push!(distances, dist_euclidean(points[i], points[j]))\n            end\n        end\n        \n        avg_dist = mean(distances)\n        std_dist = std(distances)\n        \n        println(\"  Dimension $dim: avg_distance=$(round(avg_dist, digits=3)), std=$(round(std_dist, digits=3)), ratio=$(round(std_dist/avg_dist, digits=3))\")\n    end\nend\n\ncurse_of_dimensionality_demo()","category":"page"},{"location":"datasets/#Custom-Dataset-Generation","page":"Datasets","title":"Custom Dataset Generation","text":"","category":"section"},{"location":"datasets/#Noisy-Geometric-Datasets","page":"Datasets","title":"Noisy Geometric Datasets","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"Add controlled noise to perfect geometric datasets:","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"function add_noise_to_dataset(dataset, noise_level=0.1)\n    noisy_dataset = Vector{Vector{Float64}}()\n    \n    for point in dataset\n        noisy_point = point .+ noise_level * randn(length(point))\n        push!(noisy_dataset, noisy_point)\n    end\n    \n    return noisy_dataset\nend\n\n# Create noisy versions of datasets\nnoisy_sphere = add_noise_to_dataset(sphere_points, 0.05)\nnoisy_torus = add_noise_to_dataset(torus_points, 0.1)\nnoisy_cube = add_noise_to_dataset(cube_points, 0.02)\n\nprintln(\"Created noisy versions of datasets\")","category":"page"},{"location":"datasets/#Composite-Datasets","page":"Datasets","title":"Composite Datasets","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"Combine multiple geometric objects:","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"function create_composite_dataset()\n    # Create multiple geometric objects\n    small_sphere = sphere(50, 3)\n    small_torus = torus(75)\n    small_cube = cube(60, 3)\n    \n    # Translate objects to different locations\n    translated_sphere = [point .+ [3.0, 0.0, 0.0] for point in small_sphere]\n    translated_torus = [point .+ [0.0, 3.0, 0.0] for point in small_torus]\n    translated_cube = [point .+ [0.0, 0.0, 3.0] for point in small_cube]\n    \n    # Combine all datasets\n    composite = vcat(translated_sphere, translated_torus, translated_cube)\n    \n    # Create labels for different components\n    labels = vcat(\n        fill(1, length(translated_sphere)),\n        fill(2, length(translated_torus)),\n        fill(3, length(translated_cube))\n    )\n    \n    return EuclideanSpace(composite), labels\nend\n\ncomposite_data, component_labels = create_composite_dataset()\nprintln(\"Created composite dataset with $(length(composite_data)) points\")\nprintln(\"Components: $(length(unique(component_labels)))\")","category":"page"},{"location":"datasets/#Fractal-like-Datasets","page":"Datasets","title":"Fractal-like Datasets","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"Generate datasets with fractal-like properties:","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"function sierpinski_triangle_2d(n_points=1000, n_iterations=10)\n    # Simple Sierpinski triangle using chaos game\n    vertices = [[0.0, 0.0], [1.0, 0.0], [0.5, sqrt(3)/2]]\n    \n    # Start at random point\n    current_point = [0.5, 0.25]\n    points = Vector{Vector{Float64}}()\n    \n    for i in 1:n_points\n        # Choose random vertex\n        vertex = vertices[rand(1:3)]\n        \n        # Move halfway to chosen vertex\n        current_point = 0.5 * (current_point + vertex)\n        \n        # Add point after some iterations to avoid initial transients\n        if i > n_iterations\n            push!(points, copy(current_point))\n        end\n    end\n    \n    return points\nend\n\nsierpinski_points = sierpinski_triangle_2d(2000)\nSP = EuclideanSpace(sierpinski_points)\nprintln(\"Generated Sierpinski triangle with $(length(SP)) points\")","category":"page"},{"location":"datasets/#Dataset-Utilities","page":"Datasets","title":"Dataset Utilities","text":"","category":"section"},{"location":"datasets/#Dataset-Comparison","page":"Datasets","title":"Dataset Comparison","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"Compare properties of different datasets:","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"function compare_datasets(datasets, names)\n    println(\"Dataset comparison:\")\n    println(\"Name\\t\\tPoints\\tDim\\tAvg_Dist\\tStd_Dist\\tDiameter\")\n    \n    for (dataset, name) in zip(datasets, names)\n        n_points = length(dataset)\n        dimension = length(dataset[1])\n        \n        # Sample distances for efficiency\n        sample_size = min(500, n_points * (n_points - 1) Ã· 2)\n        distances = Float64[]\n        \n        for _ in 1:sample_size\n            i, j = rand(1:n_points, 2)\n            if i != j\n                push!(distances, dist_euclidean(dataset[i], dataset[j]))\n            end\n        end\n        \n        avg_dist = mean(distances)\n        std_dist = std(distances)\n        diameter = maximum(distances)\n        \n        println(\"$name\\t\\t$n_points\\t$dimension\\t$(round(avg_dist, digits=3))\\t$(round(std_dist, digits=3))\\t$(round(diameter, digits=3))\")\n    end\nend\n\n# Compare our generated datasets\ndatasets = [sphere_points, torus_points, cube_points, sierpinski_points]\nnames = [\"Sphere\", \"Torus\", \"Cube\", \"Sierpinski\"]\ncompare_datasets(datasets, names)","category":"page"},{"location":"datasets/#Dataset-Visualization-Helpers","page":"Datasets","title":"Dataset Visualization Helpers","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"Generate data suitable for visualization:","category":"page"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"function prepare_for_visualization(dataset, max_points=200)\n    # Subsample if dataset is too large\n    if length(dataset) > max_points\n        indices = randperm(length(dataset))[1:max_points]\n        dataset = dataset[indices]\n    end\n    \n    # Extract coordinates for plotting\n    if length(dataset[1]) >= 2\n        x_coords = [point[1] for point in dataset]\n        y_coords = [point[2] for point in dataset]\n        \n        if length(dataset[1]) >= 3\n            z_coords = [point[3] for point in dataset]\n            return x_coords, y_coords, z_coords\n        else\n            return x_coords, y_coords\n        end\n    end\n    \n    return nothing\nend\n\n# Prepare sphere data for visualization\nsphere_viz = prepare_for_visualization(sphere_points, 150)\nprintln(\"Prepared sphere data for visualization: $(length(sphere_viz)) coordinates\")","category":"page"},{"location":"datasets/#Real-World-Dataset-Integration","page":"Datasets","title":"Real-World Dataset Integration","text":"","category":"section"},{"location":"datasets/#Loading-External-Data","page":"Datasets","title":"Loading External Data","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"function load_point_cloud_from_matrix(matrix_data)\n    # Convert matrix (points as columns) to EuclideanSpace\n    points = [matrix_data[:, i] for i in 1:size(matrix_data, 2)]\n    return EuclideanSpace(points)\nend\n\n# Example: Create EuclideanSpace from random matrix\nrandom_matrix = randn(4, 100)  # 4D points, 100 samples\nexternal_data = load_point_cloud_from_matrix(random_matrix)\nprintln(\"Loaded external data: $(length(external_data)) points in $(length(external_data[1]))D\")","category":"page"},{"location":"datasets/#Dataset-Preprocessing","page":"Datasets","title":"Dataset Preprocessing","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"function preprocess_dataset(dataset; center=true, normalize=true, remove_duplicates=true)\n    processed = copy(dataset)\n    \n    # Remove duplicates\n    if remove_duplicates\n        unique_points = Vector{Vector{Float64}}()\n        seen = Set{Vector{Float64}}()\n        \n        for point in processed\n            if !(point in seen)\n                push!(unique_points, point)\n                push!(seen, point)\n            end\n        end\n        processed = unique_points\n        println(\"Removed $(length(dataset) - length(processed)) duplicate points\")\n    end\n    \n    # Center data\n    if center && length(processed) > 0\n        centroid = mean(processed)\n        processed = [point .- centroid for point in processed]\n        println(\"Centered dataset at origin\")\n    end\n    \n    # Normalize to unit variance\n    if normalize && length(processed) > 1\n        # Compute overall standard deviation\n        all_coords = vcat([point for point in processed]...)\n        overall_std = std(all_coords)\n        \n        if overall_std > 1e-10\n            processed = [point ./ overall_std for point in processed]\n            println(\"Normalized dataset to unit variance\")\n        end\n    end\n    \n    return EuclideanSpace(processed)\nend\n\n# Example preprocessing\nraw_data = vcat(sphere_points, sphere_points[1:10])  # Add some duplicates\nprocessed_data = preprocess_dataset(raw_data)","category":"page"},{"location":"datasets/#Performance-Benchmarks","page":"Datasets","title":"Performance Benchmarks","text":"","category":"section"},{"location":"datasets/#Dataset-Generation-Performance","page":"Datasets","title":"Dataset Generation Performance","text":"","category":"section"},{"location":"datasets/","page":"Datasets","title":"Datasets","text":"using BenchmarkTools\n\nfunction benchmark_dataset_generation()\n    println(\"Dataset generation benchmarks:\")\n    \n    # Sphere generation\n    println(\"Sphere generation (1000 points, 3D):\")\n    @btime sphere(1000, 3)\n    \n    # Torus generation  \n    println(\"Torus generation (1000 points):\")\n    @btime torus(1000)\n    \n    # Cube generation\n    println(\"Cube generation (1000 points, 3D):\")\n    @btime cube(1000, 3)\nend\n\nbenchmark_dataset_generation()","category":"page"}]
}
