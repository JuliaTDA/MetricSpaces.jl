<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Datasets · MetricSpaces.jl</title><meta name="title" content="Datasets · MetricSpaces.jl"/><meta property="og:title" content="Datasets · MetricSpaces.jl"/><meta property="twitter:title" content="Datasets · MetricSpaces.jl"/><meta name="description" content="Documentation for MetricSpaces.jl."/><meta property="og:description" content="Documentation for MetricSpaces.jl."/><meta property="twitter:description" content="Documentation for MetricSpaces.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MetricSpaces.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../mathematical_background/">Mathematical Background</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../types/">Core Types</a></li><li><a class="tocitem" href="../distances/">Distance Functions</a></li><li><a class="tocitem" href="../balls/">Metric Balls</a></li><li><a class="tocitem" href="../sampling/">Sampling Methods</a></li><li><a class="tocitem" href="../neighborhoods/">Neighborhood Analysis</a></li><li class="is-active"><a class="tocitem" href>Datasets</a><ul class="internal"><li><a class="tocitem" href="#Geometric-Datasets"><span>Geometric Datasets</span></a></li><li><a class="tocitem" href="#Custom-Dataset-Generation"><span>Custom Dataset Generation</span></a></li><li><a class="tocitem" href="#Dataset-Utilities"><span>Dataset Utilities</span></a></li><li><a class="tocitem" href="#Real-World-Dataset-Integration"><span>Real-World Dataset Integration</span></a></li><li><a class="tocitem" href="#Performance-Benchmarks"><span>Performance Benchmarks</span></a></li></ul></li><li><a class="tocitem" href="../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Datasets</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Datasets</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaTDA/MetricSpaces.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaTDA/MetricSpaces.jl/blob/main/docs/src/datasets.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Datasets"><a class="docs-heading-anchor" href="#Datasets">Datasets</a><a id="Datasets-1"></a><a class="docs-heading-anchor-permalink" href="#Datasets" title="Permalink"></a></h1><p>MetricSpaces.jl provides several built-in geometric datasets commonly used in topological data analysis and computational geometry research.</p><h2 id="Geometric-Datasets"><a class="docs-heading-anchor" href="#Geometric-Datasets">Geometric Datasets</a><a id="Geometric-Datasets-1"></a><a class="docs-heading-anchor-permalink" href="#Geometric-Datasets" title="Permalink"></a></h2><h3 id="Sphere"><a class="docs-heading-anchor" href="#Sphere">Sphere</a><a id="Sphere-1"></a><a class="docs-heading-anchor-permalink" href="#Sphere" title="Permalink"></a></h3><p>Generate points on the surface of an n-dimensional sphere.</p><h4 id="sphere(n_points,-dimension)"><a class="docs-heading-anchor" href="#sphere(n_points,-dimension)"><code>sphere(n_points, dimension)</code></a><a id="sphere(n_points,-dimension)-1"></a><a class="docs-heading-anchor-permalink" href="#sphere(n_points,-dimension)" title="Permalink"></a></h4><pre><code class="language-julia hljs">sphere(n_points::Int, dimension::Int)</code></pre><p><strong>Parameters:</strong></p><ul><li><code>n_points</code>: Number of points to generate</li><li><code>dimension</code>: Dimension of the sphere (2 for circle, 3 for standard sphere, etc.)</li></ul><p><strong>Mathematical Background:</strong> Points are generated on the unit sphere <span>$S^{n-1} \subset \mathbb{R}^n$</span>:</p><p class="math-container">\[S^{n-1} = \{x \in \mathbb{R}^n : \|x\|_2 = 1\}\]</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs"># Generate 100 points on a 2-sphere (surface of a ball in 3D)
sphere_points = sphere(100, 3)
S = EuclideanSpace(sphere_points)

println(&quot;Generated $(length(S)) points on a 2-sphere&quot;)
println(&quot;First point: $(S[1])&quot;)
println(&quot;Distance from origin: $(norm(S[1]))&quot;)  # Should be ≈ 1.0

# Verify points are on unit sphere
distances_from_origin = [norm(point) for point in S]
println(&quot;All points on unit sphere: &quot;, all(abs.(distances_from_origin .- 1.0) .&lt; 1e-10))</code></pre><h3 id="Applications-of-Sphere-Data"><a class="docs-heading-anchor" href="#Applications-of-Sphere-Data">Applications of Sphere Data</a><a id="Applications-of-Sphere-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Applications-of-Sphere-Data" title="Permalink"></a></h3><p><strong>Clustering on Spheres:</strong></p><pre><code class="language-julia hljs"># Spherical data often requires specialized clustering
function spherical_kmeans_demo(sphere_data, k=3)
    # Simple spherical k-means (not implemented in full here)
    # In practice, use specialized spherical clustering algorithms
    
    # For demonstration, use standard k-means on sphere data
    centers = sphere_data[randperm(length(sphere_data))[1:k]]
    
    println(&quot;Spherical clustering with $k centers:&quot;)
    for (i, center) in enumerate(centers)
        println(&quot;  Center $i: $(round.(center, digits=3))&quot;)
    end
    
    return centers
end

sphere_centers = spherical_kmeans_demo(sphere_points, 4)</code></pre><h3 id="Torus"><a class="docs-heading-anchor" href="#Torus">Torus</a><a id="Torus-1"></a><a class="docs-heading-anchor-permalink" href="#Torus" title="Permalink"></a></h3><p>Generate points on the surface of a torus.</p><h4 id="torus(n_points)"><a class="docs-heading-anchor" href="#torus(n_points)"><code>torus(n_points)</code></a><a id="torus(n_points)-1"></a><a class="docs-heading-anchor-permalink" href="#torus(n_points)" title="Permalink"></a></h4><pre><code class="language-julia hljs">torus(n_points::Int)</code></pre><p><strong>Mathematical Background:</strong> A torus is parameterized by two angles <span>$(θ, φ)$</span>:</p><p class="math-container">\[\begin{align}
x &amp;= (R + r\cos φ) \cos θ \\
y &amp;= (R + r\cos φ) \sin θ \\
z &amp;= r \sin φ
\end{align}\]</p><p>where <span>$R$</span> is the major radius and <span>$r$</span> is the minor radius.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs"># Generate 200 points on a torus
torus_points = torus(200)
T = EuclideanSpace(torus_points)

println(&quot;Generated $(length(T)) points on a torus&quot;)
println(&quot;Sample points:&quot;)
for i in 1:3
    println(&quot;  Point $i: $(round.(T[i], digits=3))&quot;)
end

# Analyze torus structure
function analyze_torus_structure(torus_data)
    # Distance from z-axis (should reveal torus structure)
    xy_distances = [sqrt(point[1]^2 + point[2]^2) for point in torus_data]
    z_coordinates = [point[3] for point in torus_data]
    
    println(&quot;Torus analysis:&quot;)
    println(&quot;  XY distances - min: $(round(minimum(xy_distances), digits=3)), max: $(round(maximum(xy_distances), digits=3))&quot;)
    println(&quot;  Z coordinates - min: $(round(minimum(z_coordinates), digits=3)), max: $(round(maximum(z_coordinates), digits=3))&quot;)
    
    return xy_distances, z_coordinates
end

xy_dists, z_coords = analyze_torus_structure(torus_points)</code></pre><h3 id="Applications-of-Torus-Data"><a class="docs-heading-anchor" href="#Applications-of-Torus-Data">Applications of Torus Data</a><a id="Applications-of-Torus-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Applications-of-Torus-Data" title="Permalink"></a></h3><p><strong>Persistent Homology:</strong></p><pre><code class="language-julia hljs"># Torus data is excellent for testing persistent homology algorithms
# The torus has known topology: H_0 = ℤ, H_1 = ℤ², H_2 = ℤ

function torus_homology_demo(torus_data)
    # Compute some basic topological features
    # (This would typically use a specialized TDA library)
    
    # For demonstration: analyze 1-dimensional holes using simple graph methods
    using Graphs
    
    # Build neighborhood graph
    g = SimpleGraph(length(torus_data))
    threshold = 0.5  # Connection threshold
    
    for i in 1:length(torus_data)
        for j in (i+1):length(torus_data)
            if dist_euclidean(torus_data[i], torus_data[j]) &lt; threshold
                add_edge!(g, i, j)
            end
        end
    end
    
    components = connected_components(g)
    println(&quot;Graph analysis at threshold $threshold:&quot;)
    println(&quot;  Connected components: $(length(components))&quot;)
    println(&quot;  Edges: $(ne(g))&quot;)
    
    return g
end

torus_graph = torus_homology_demo(torus_points)</code></pre><h3 id="Cube"><a class="docs-heading-anchor" href="#Cube">Cube</a><a id="Cube-1"></a><a class="docs-heading-anchor-permalink" href="#Cube" title="Permalink"></a></h3><p>Generate points uniformly distributed in an n-dimensional cube.</p><h4 id="cube(n_points,-dimension)"><a class="docs-heading-anchor" href="#cube(n_points,-dimension)"><code>cube(n_points, dimension)</code></a><a id="cube(n_points,-dimension)-1"></a><a class="docs-heading-anchor-permalink" href="#cube(n_points,-dimension)" title="Permalink"></a></h4><pre><code class="language-julia hljs">cube(n_points::Int, dimension::Int)</code></pre><p><strong>Mathematical Background:</strong> Points are generated uniformly in the unit cube <span>$[0,1]^n$</span>:</p><p class="math-container">\[\{x \in \mathbb{R}^n : 0 \leq x_i \leq 1 \text{ for all } i\}\]</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs"># Generate 150 points in a 3D cube
cube_points = cube(150, 3)
C = EuclideanSpace(cube_points)

println(&quot;Generated $(length(C)) points in a 3D cube&quot;)

# Verify points are in unit cube
function verify_cube_bounds(cube_data, dimension)
    all_in_bounds = true
    for point in cube_data
        for coord in point
            if coord &lt; 0 || coord &gt; 1
                all_in_bounds = false
                break
            end
        end
        if !all_in_bounds
            break
        end
    end
    
    println(&quot;All points in unit cube: $all_in_bounds&quot;)
    return all_in_bounds
end

verify_cube_bounds(cube_points, 3)

# Analyze cube properties
function analyze_cube_distribution(cube_data)
    dimension = length(cube_data[1])
    
    println(&quot;Cube distribution analysis:&quot;)
    for dim in 1:dimension
        coords = [point[dim] for point in cube_data]
        println(&quot;  Dimension $dim: mean=$(round(mean(coords), digits=3)), std=$(round(std(coords), digits=3))&quot;)
    end
    
    # Check for uniform distribution (should be close to uniform)
    return [mean([point[dim] for point in cube_data]) for dim in 1:dimension]
end

means = analyze_cube_distribution(cube_points)</code></pre><h3 id="Applications-of-Cube-Data"><a class="docs-heading-anchor" href="#Applications-of-Cube-Data">Applications of Cube Data</a><a id="Applications-of-Cube-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Applications-of-Cube-Data" title="Permalink"></a></h3><p><strong>Curse of Dimensionality Studies:</strong></p><pre><code class="language-julia hljs">function curse_of_dimensionality_demo(dimensions=[2, 5, 10, 20])
    println(&quot;Curse of dimensionality demonstration:&quot;)
    
    for dim in dimensions
        # Generate points in high-dimensional cube
        n_points = 1000
        points = cube(n_points, dim)
        
        # Compute pairwise distances
        distances = Float64[]
        for i in 1:min(100, n_points)  # Sample for efficiency
            for j in (i+1):min(100, n_points)
                push!(distances, dist_euclidean(points[i], points[j]))
            end
        end
        
        avg_dist = mean(distances)
        std_dist = std(distances)
        
        println(&quot;  Dimension $dim: avg_distance=$(round(avg_dist, digits=3)), std=$(round(std_dist, digits=3)), ratio=$(round(std_dist/avg_dist, digits=3))&quot;)
    end
end

curse_of_dimensionality_demo()</code></pre><h2 id="Custom-Dataset-Generation"><a class="docs-heading-anchor" href="#Custom-Dataset-Generation">Custom Dataset Generation</a><a id="Custom-Dataset-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Dataset-Generation" title="Permalink"></a></h2><h3 id="Noisy-Geometric-Datasets"><a class="docs-heading-anchor" href="#Noisy-Geometric-Datasets">Noisy Geometric Datasets</a><a id="Noisy-Geometric-Datasets-1"></a><a class="docs-heading-anchor-permalink" href="#Noisy-Geometric-Datasets" title="Permalink"></a></h3><p>Add controlled noise to perfect geometric datasets:</p><pre><code class="language-julia hljs">function add_noise_to_dataset(dataset, noise_level=0.1)
    noisy_dataset = Vector{Vector{Float64}}()
    
    for point in dataset
        noisy_point = point .+ noise_level * randn(length(point))
        push!(noisy_dataset, noisy_point)
    end
    
    return noisy_dataset
end

# Create noisy versions of datasets
noisy_sphere = add_noise_to_dataset(sphere_points, 0.05)
noisy_torus = add_noise_to_dataset(torus_points, 0.1)
noisy_cube = add_noise_to_dataset(cube_points, 0.02)

println(&quot;Created noisy versions of datasets&quot;)</code></pre><h3 id="Composite-Datasets"><a class="docs-heading-anchor" href="#Composite-Datasets">Composite Datasets</a><a id="Composite-Datasets-1"></a><a class="docs-heading-anchor-permalink" href="#Composite-Datasets" title="Permalink"></a></h3><p>Combine multiple geometric objects:</p><pre><code class="language-julia hljs">function create_composite_dataset()
    # Create multiple geometric objects
    small_sphere = sphere(50, 3)
    small_torus = torus(75)
    small_cube = cube(60, 3)
    
    # Translate objects to different locations
    translated_sphere = [point .+ [3.0, 0.0, 0.0] for point in small_sphere]
    translated_torus = [point .+ [0.0, 3.0, 0.0] for point in small_torus]
    translated_cube = [point .+ [0.0, 0.0, 3.0] for point in small_cube]
    
    # Combine all datasets
    composite = vcat(translated_sphere, translated_torus, translated_cube)
    
    # Create labels for different components
    labels = vcat(
        fill(1, length(translated_sphere)),
        fill(2, length(translated_torus)),
        fill(3, length(translated_cube))
    )
    
    return EuclideanSpace(composite), labels
end

composite_data, component_labels = create_composite_dataset()
println(&quot;Created composite dataset with $(length(composite_data)) points&quot;)
println(&quot;Components: $(length(unique(component_labels)))&quot;)</code></pre><h3 id="Fractal-like-Datasets"><a class="docs-heading-anchor" href="#Fractal-like-Datasets">Fractal-like Datasets</a><a id="Fractal-like-Datasets-1"></a><a class="docs-heading-anchor-permalink" href="#Fractal-like-Datasets" title="Permalink"></a></h3><p>Generate datasets with fractal-like properties:</p><pre><code class="language-julia hljs">function sierpinski_triangle_2d(n_points=1000, n_iterations=10)
    # Simple Sierpinski triangle using chaos game
    vertices = [[0.0, 0.0], [1.0, 0.0], [0.5, sqrt(3)/2]]
    
    # Start at random point
    current_point = [0.5, 0.25]
    points = Vector{Vector{Float64}}()
    
    for i in 1:n_points
        # Choose random vertex
        vertex = vertices[rand(1:3)]
        
        # Move halfway to chosen vertex
        current_point = 0.5 * (current_point + vertex)
        
        # Add point after some iterations to avoid initial transients
        if i &gt; n_iterations
            push!(points, copy(current_point))
        end
    end
    
    return points
end

sierpinski_points = sierpinski_triangle_2d(2000)
SP = EuclideanSpace(sierpinski_points)
println(&quot;Generated Sierpinski triangle with $(length(SP)) points&quot;)</code></pre><h2 id="Dataset-Utilities"><a class="docs-heading-anchor" href="#Dataset-Utilities">Dataset Utilities</a><a id="Dataset-Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Dataset-Utilities" title="Permalink"></a></h2><h3 id="Dataset-Comparison"><a class="docs-heading-anchor" href="#Dataset-Comparison">Dataset Comparison</a><a id="Dataset-Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Dataset-Comparison" title="Permalink"></a></h3><p>Compare properties of different datasets:</p><pre><code class="language-julia hljs">function compare_datasets(datasets, names)
    println(&quot;Dataset comparison:&quot;)
    println(&quot;Name\t\tPoints\tDim\tAvg_Dist\tStd_Dist\tDiameter&quot;)
    
    for (dataset, name) in zip(datasets, names)
        n_points = length(dataset)
        dimension = length(dataset[1])
        
        # Sample distances for efficiency
        sample_size = min(500, n_points * (n_points - 1) ÷ 2)
        distances = Float64[]
        
        for _ in 1:sample_size
            i, j = rand(1:n_points, 2)
            if i != j
                push!(distances, dist_euclidean(dataset[i], dataset[j]))
            end
        end
        
        avg_dist = mean(distances)
        std_dist = std(distances)
        diameter = maximum(distances)
        
        println(&quot;$name\t\t$n_points\t$dimension\t$(round(avg_dist, digits=3))\t$(round(std_dist, digits=3))\t$(round(diameter, digits=3))&quot;)
    end
end

# Compare our generated datasets
datasets = [sphere_points, torus_points, cube_points, sierpinski_points]
names = [&quot;Sphere&quot;, &quot;Torus&quot;, &quot;Cube&quot;, &quot;Sierpinski&quot;]
compare_datasets(datasets, names)</code></pre><h3 id="Dataset-Visualization-Helpers"><a class="docs-heading-anchor" href="#Dataset-Visualization-Helpers">Dataset Visualization Helpers</a><a id="Dataset-Visualization-Helpers-1"></a><a class="docs-heading-anchor-permalink" href="#Dataset-Visualization-Helpers" title="Permalink"></a></h3><p>Generate data suitable for visualization:</p><pre><code class="language-julia hljs">function prepare_for_visualization(dataset, max_points=200)
    # Subsample if dataset is too large
    if length(dataset) &gt; max_points
        indices = randperm(length(dataset))[1:max_points]
        dataset = dataset[indices]
    end
    
    # Extract coordinates for plotting
    if length(dataset[1]) &gt;= 2
        x_coords = [point[1] for point in dataset]
        y_coords = [point[2] for point in dataset]
        
        if length(dataset[1]) &gt;= 3
            z_coords = [point[3] for point in dataset]
            return x_coords, y_coords, z_coords
        else
            return x_coords, y_coords
        end
    end
    
    return nothing
end

# Prepare sphere data for visualization
sphere_viz = prepare_for_visualization(sphere_points, 150)
println(&quot;Prepared sphere data for visualization: $(length(sphere_viz)) coordinates&quot;)</code></pre><h2 id="Real-World-Dataset-Integration"><a class="docs-heading-anchor" href="#Real-World-Dataset-Integration">Real-World Dataset Integration</a><a id="Real-World-Dataset-Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Real-World-Dataset-Integration" title="Permalink"></a></h2><h3 id="Loading-External-Data"><a class="docs-heading-anchor" href="#Loading-External-Data">Loading External Data</a><a id="Loading-External-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-External-Data" title="Permalink"></a></h3><pre><code class="language-julia hljs">function load_point_cloud_from_matrix(matrix_data)
    # Convert matrix (points as columns) to EuclideanSpace
    points = [matrix_data[:, i] for i in 1:size(matrix_data, 2)]
    return EuclideanSpace(points)
end

# Example: Create EuclideanSpace from random matrix
random_matrix = randn(4, 100)  # 4D points, 100 samples
external_data = load_point_cloud_from_matrix(random_matrix)
println(&quot;Loaded external data: $(length(external_data)) points in $(length(external_data[1]))D&quot;)</code></pre><h3 id="Dataset-Preprocessing"><a class="docs-heading-anchor" href="#Dataset-Preprocessing">Dataset Preprocessing</a><a id="Dataset-Preprocessing-1"></a><a class="docs-heading-anchor-permalink" href="#Dataset-Preprocessing" title="Permalink"></a></h3><pre><code class="language-julia hljs">function preprocess_dataset(dataset; center=true, normalize=true, remove_duplicates=true)
    processed = copy(dataset)
    
    # Remove duplicates
    if remove_duplicates
        unique_points = Vector{Vector{Float64}}()
        seen = Set{Vector{Float64}}()
        
        for point in processed
            if !(point in seen)
                push!(unique_points, point)
                push!(seen, point)
            end
        end
        processed = unique_points
        println(&quot;Removed $(length(dataset) - length(processed)) duplicate points&quot;)
    end
    
    # Center data
    if center &amp;&amp; length(processed) &gt; 0
        centroid = mean(processed)
        processed = [point .- centroid for point in processed]
        println(&quot;Centered dataset at origin&quot;)
    end
    
    # Normalize to unit variance
    if normalize &amp;&amp; length(processed) &gt; 1
        # Compute overall standard deviation
        all_coords = vcat([point for point in processed]...)
        overall_std = std(all_coords)
        
        if overall_std &gt; 1e-10
            processed = [point ./ overall_std for point in processed]
            println(&quot;Normalized dataset to unit variance&quot;)
        end
    end
    
    return EuclideanSpace(processed)
end

# Example preprocessing
raw_data = vcat(sphere_points, sphere_points[1:10])  # Add some duplicates
processed_data = preprocess_dataset(raw_data)</code></pre><h2 id="Performance-Benchmarks"><a class="docs-heading-anchor" href="#Performance-Benchmarks">Performance Benchmarks</a><a id="Performance-Benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Benchmarks" title="Permalink"></a></h2><h3 id="Dataset-Generation-Performance"><a class="docs-heading-anchor" href="#Dataset-Generation-Performance">Dataset Generation Performance</a><a id="Dataset-Generation-Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Dataset-Generation-Performance" title="Permalink"></a></h3><pre><code class="language-julia hljs">using BenchmarkTools

function benchmark_dataset_generation()
    println(&quot;Dataset generation benchmarks:&quot;)
    
    # Sphere generation
    println(&quot;Sphere generation (1000 points, 3D):&quot;)
    @btime sphere(1000, 3)
    
    # Torus generation  
    println(&quot;Torus generation (1000 points):&quot;)
    @btime torus(1000)
    
    # Cube generation
    println(&quot;Cube generation (1000 points, 3D):&quot;)
    @btime cube(1000, 3)
end

benchmark_dataset_generation()</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../neighborhoods/">« Neighborhood Analysis</a><a class="docs-footer-nextpage" href="../api/">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Thursday 12 June 2025 01:53">Thursday 12 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
