<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Neighborhood Analysis · MetricSpaces.jl</title><meta name="title" content="Neighborhood Analysis · MetricSpaces.jl"/><meta property="og:title" content="Neighborhood Analysis · MetricSpaces.jl"/><meta property="twitter:title" content="Neighborhood Analysis · MetricSpaces.jl"/><meta name="description" content="Documentation for MetricSpaces.jl."/><meta property="og:description" content="Documentation for MetricSpaces.jl."/><meta property="twitter:description" content="Documentation for MetricSpaces.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MetricSpaces.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../mathematical_background/">Mathematical Background</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../types/">Core Types</a></li><li><a class="tocitem" href="../distances/">Distance Functions</a></li><li><a class="tocitem" href="../balls/">Metric Balls</a></li><li><a class="tocitem" href="../sampling/">Sampling Methods</a></li><li class="is-active"><a class="tocitem" href>Neighborhood Analysis</a><ul class="internal"><li><a class="tocitem" href="#k-Nearest-Neighbors"><span>k-Nearest Neighbors</span></a></li><li><a class="tocitem" href="#Distance-to-Measure"><span>Distance-to-Measure</span></a></li><li><a class="tocitem" href="#Eccentricity"><span>Eccentricity</span></a></li><li><a class="tocitem" href="#Local-Dimension-Estimation"><span>Local Dimension Estimation</span></a></li><li><a class="tocitem" href="#Neighborhood-Graphs"><span>Neighborhood Graphs</span></a></li><li><a class="tocitem" href="#Advanced-Neighborhood-Analysis"><span>Advanced Neighborhood Analysis</span></a></li><li><a class="tocitem" href="#Applications-in-Data-Analysis"><span>Applications in Data Analysis</span></a></li></ul></li><li><a class="tocitem" href="../datasets/">Datasets</a></li><li><a class="tocitem" href="../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Neighborhood Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Neighborhood Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaTDA/MetricSpaces.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaTDA/MetricSpaces.jl/blob/main/docs/src/neighborhoods.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Neighborhood-Analysis"><a class="docs-heading-anchor" href="#Neighborhood-Analysis">Neighborhood Analysis</a><a id="Neighborhood-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Neighborhood-Analysis" title="Permalink"></a></h1><p>MetricSpaces.jl provides tools for analyzing the local structure of metric spaces through neighborhood-based computations. These methods are essential for understanding local geometry, density, and topological properties.</p><h2 id="k-Nearest-Neighbors"><a class="docs-heading-anchor" href="#k-Nearest-Neighbors">k-Nearest Neighbors</a><a id="k-Nearest-Neighbors-1"></a><a class="docs-heading-anchor-permalink" href="#k-Nearest-Neighbors" title="Permalink"></a></h2><p>Find the k closest points to a given query point.</p><h3 id="k_neighbors"><a class="docs-heading-anchor" href="#k_neighbors"><code>k_neighbors</code></a><a id="k_neighbors-1"></a><a class="docs-heading-anchor-permalink" href="#k_neighbors" title="Permalink"></a></h3><pre><code class="language-julia hljs">k_neighbors(X::MetricSpace, query_point, k::Int; d=dist_euclidean)</code></pre><p><strong>Example:</strong></p><pre><code class="language-julia hljs"># Create sample data
points = [[0.0, 0.0], [1.0, 0.0], [0.0, 1.0], [1.0, 1.0], [2.0, 0.0], [0.0, 2.0]]
X = EuclideanSpace(points)

# Find 3 nearest neighbors of origin
query = [0.0, 0.0]
neighbors = k_neighbors(X, query, 3)

println(&quot;3 nearest neighbors of $query:&quot;)
for (i, neighbor_idx) in enumerate(neighbors)
    point = X[neighbor_idx]
    dist = dist_euclidean(query, point)
    println(&quot;  $i: Point $neighbor_idx = $point (distance: $(round(dist, digits=3)))&quot;)
end</code></pre><h3 id="Properties-of-k-NN"><a class="docs-heading-anchor" href="#Properties-of-k-NN">Properties of k-NN</a><a id="Properties-of-k-NN-1"></a><a class="docs-heading-anchor-permalink" href="#Properties-of-k-NN" title="Permalink"></a></h3><ul><li><strong>Asymmetry</strong>: If A is a k-neighbor of B, B might not be a k-neighbor of A</li><li><strong>Locality</strong>: Captures local structure around each point</li><li><strong>Scale-free</strong>: Adapts to local density variations</li></ul><pre><code class="language-julia hljs"># Analyze k-NN asymmetry
function analyze_knn_asymmetry(X::EuclideanSpace, k::Int)
    n = length(X)
    asymmetric_pairs = 0
    total_pairs = 0
    
    for i in 1:n
        neighbors_i = k_neighbors(X, X[i], k)
        
        for neighbor_idx in neighbors_i
            total_pairs += 1
            neighbors_j = k_neighbors(X, X[neighbor_idx], k)
            
            if !(i in neighbors_j)
                asymmetric_pairs += 1
            end
        end
    end
    
    asymmetry_rate = asymmetric_pairs / total_pairs
    println(&quot;k-NN asymmetry rate: $(round(asymmetry_rate * 100, digits=1))%&quot;)
    return asymmetry_rate
end

asymmetry = analyze_knn_asymmetry(X, 2)</code></pre><h2 id="Distance-to-Measure"><a class="docs-heading-anchor" href="#Distance-to-Measure">Distance-to-Measure</a><a id="Distance-to-Measure-1"></a><a class="docs-heading-anchor-permalink" href="#Distance-to-Measure" title="Permalink"></a></h2><p>Compute density-based measures for outlier detection and filtering.</p><h3 id="distance_to_measure"><a class="docs-heading-anchor" href="#distance_to_measure"><code>distance_to_measure</code></a><a id="distance_to_measure-1"></a><a class="docs-heading-anchor-permalink" href="#distance_to_measure" title="Permalink"></a></h3><pre><code class="language-julia hljs">distance_to_measure(X::MetricSpace, mass_parameter::Float64; d=dist_euclidean)</code></pre><p>The distance-to-measure <span>$d_{μ,m}(x)$</span> for a point <span>$x$</span> is the minimum radius needed for a ball centered at <span>$x$</span> to contain at least mass <span>$m$</span> of the total measure.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs"># Create data with outliers
normal_points = [randn(2) for _ in 1:50]  # Clustered points
outliers = [[10.0, 10.0], [-8.0, -8.0]]   # Clear outliers
all_points = vcat(normal_points, outliers)
X_outliers = EuclideanSpace(all_points)

# Compute distance to measure with 10% mass
mass_param = 0.1
dtm_values = distance_to_measure(X_outliers, mass_param)

println(&quot;Distance to measure analysis:&quot;)
println(&quot;Normal points (first 5): &quot;, round.(dtm_values[1:5], digits=3))
println(&quot;Outliers: &quot;, round.(dtm_values[end-1:end], digits=3))

# Identify outliers (high DTM values)
threshold = quantile(dtm_values, 0.9)  # Top 10% as outliers
outlier_indices = findall(x -&gt; x &gt; threshold, dtm_values)
println(&quot;Detected outlier indices: &quot;, outlier_indices)</code></pre><h3 id="DTM-Applications"><a class="docs-heading-anchor" href="#DTM-Applications">DTM Applications</a><a id="DTM-Applications-1"></a><a class="docs-heading-anchor-permalink" href="#DTM-Applications" title="Permalink"></a></h3><p><strong>Density Estimation:</strong></p><pre><code class="language-julia hljs">function estimate_density_dtm(X::EuclideanSpace, mass_param=0.05)
    dtm_vals = distance_to_measure(X, mass_param)
    # Density inversely related to DTM
    densities = 1.0 ./ (dtm_vals .+ 1e-10)  # Add small value to avoid division by zero
    return densities ./ sum(densities)  # Normalize
end

densities = estimate_density_dtm(X_outliers)</code></pre><p><strong>Robust Filtering:</strong></p><pre><code class="language-julia hljs">function robust_filter(X::EuclideanSpace, mass_param=0.1, quantile_threshold=0.8)
    dtm_vals = distance_to_measure(X, mass_param)
    threshold = quantile(dtm_vals, quantile_threshold)
    
    # Keep points with low DTM (high density regions)
    filtered_indices = findall(x -&gt; x &lt;= threshold, dtm_vals)
    return filtered_indices
end

filtered_indices = robust_filter(X_outliers, 0.1, 0.8)
filtered_points = X_outliers[filtered_indices]
println(&quot;Filtered from $(length(X_outliers)) to $(length(filtered_points)) points&quot;)</code></pre><h2 id="Eccentricity"><a class="docs-heading-anchor" href="#Eccentricity">Eccentricity</a><a id="Eccentricity-1"></a><a class="docs-heading-anchor-permalink" href="#Eccentricity" title="Permalink"></a></h2><p>Measure how &quot;central&quot; each point is within the metric space.</p><h3 id="excentricity"><a class="docs-heading-anchor" href="#excentricity"><code>excentricity</code></a><a id="excentricity-1"></a><a class="docs-heading-anchor-permalink" href="#excentricity" title="Permalink"></a></h3><pre><code class="language-julia hljs">excentricity(X::MetricSpace; d=dist_euclidean)</code></pre><p>The eccentricity of a point is its maximum distance to any other point in the space.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs"># Create data with clear center and boundary points
center_points = [0.1 * randn(2) for _ in 1:20]  # Tight cluster at origin
boundary_points = [5.0 * normalize(randn(2)) for _ in 1:10]  # Points on boundary
mixed_data = vcat(center_points, boundary_points)
X_mixed = EuclideanSpace(mixed_data)

# Compute eccentricity
eccentricities = excentricity(X_mixed)

println(&quot;Eccentricity analysis:&quot;)
println(&quot;Center points (first 5): &quot;, round.(eccentricities[1:5], digits=3))
println(&quot;Boundary points (last 5): &quot;, round.(eccentricities[end-4:end], digits=3))

# Find most central point (minimum eccentricity)
most_central_idx = argmin(eccentricities)
most_eccentric_idx = argmax(eccentricities)

println(&quot;Most central point: index $most_central_idx, eccentricity $(round(eccentricities[most_central_idx], digits=3))&quot;)
println(&quot;Most eccentric point: index $most_eccentric_idx, eccentricity $(round(eccentricities[most_eccentric_idx], digits=3))&quot;)</code></pre><h3 id="Eccentricity-Applications"><a class="docs-heading-anchor" href="#Eccentricity-Applications">Eccentricity Applications</a><a id="Eccentricity-Applications-1"></a><a class="docs-heading-anchor-permalink" href="#Eccentricity-Applications" title="Permalink"></a></h3><p><strong>Geometric Center Finding:</strong></p><pre><code class="language-julia hljs">function find_geometric_center(X::EuclideanSpace)
    ecc_values = excentricity(X)
    center_idx = argmin(ecc_values)
    return center_idx, X[center_idx]
end

center_idx, center_point = find_geometric_center(X_mixed)
println(&quot;Geometric center: $center_point at index $center_idx&quot;)</code></pre><p><strong>Boundary Detection:</strong></p><pre><code class="language-julia hljs">function detect_boundary_points(X::EuclideanSpace, percentile=90)
    ecc_values = excentricity(X)
    threshold = quantile(ecc_values, percentile/100)
    boundary_indices = findall(x -&gt; x &gt;= threshold, ecc_values)
    return boundary_indices
end

boundary_indices = detect_boundary_points(X_mixed, 80)
println(&quot;Boundary points (top 20%): &quot;, boundary_indices)</code></pre><h2 id="Local-Dimension-Estimation"><a class="docs-heading-anchor" href="#Local-Dimension-Estimation">Local Dimension Estimation</a><a id="Local-Dimension-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Local-Dimension-Estimation" title="Permalink"></a></h2><p>Estimate the local intrinsic dimension around each point.</p><pre><code class="language-julia hljs">using LinearAlgebra

function estimate_local_dimension(X::EuclideanSpace, k::Int=10; method=:pca)
    local_dimensions = Float64[]
    
    for i in 1:length(X)
        # Get k nearest neighbors
        neighbor_indices = k_neighbors(X, X[i], k)
        neighbor_points = [X[j] for j in neighbor_indices]
        
        if method == :pca
            # Center the neighbor points
            center = mean(neighbor_points)
            centered_points = [p .- center for p in neighbor_points]
            
            # Create data matrix (points as columns)
            data_matrix = hcat(centered_points...)
            
            # Compute SVD
            U, S, V = svd(data_matrix)
            
            # Estimate dimension based on singular value decay
            # Simple approach: count significant singular values
            total_variance = sum(S.^2)
            cumulative_variance = cumsum(S.^2) / total_variance
            
            # Find dimension needed to capture 90% of variance
            dim_estimate = findfirst(x -&gt; x &gt; 0.9, cumulative_variance)
            dim_estimate = dim_estimate === nothing ? length(S) : dim_estimate
            
        else
            # Fallback: use ambient dimension
            dim_estimate = length(X[1])
        end
        
        push!(local_dimensions, dim_estimate)
    end
    
    return local_dimensions
end

# Example usage
local_dims = estimate_local_dimension(X_mixed, 5)
println(&quot;Local dimension estimates:&quot;)
println(&quot;Mean: $(round(mean(local_dims), digits=2))&quot;)
println(&quot;Range: $(minimum(local_dims)) - $(maximum(local_dims))&quot;)</code></pre><h2 id="Neighborhood-Graphs"><a class="docs-heading-anchor" href="#Neighborhood-Graphs">Neighborhood Graphs</a><a id="Neighborhood-Graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Neighborhood-Graphs" title="Permalink"></a></h2><p>Construct graphs based on neighborhood relationships.</p><h3 id="k-NN-Graph"><a class="docs-heading-anchor" href="#k-NN-Graph">k-NN Graph</a><a id="k-NN-Graph-1"></a><a class="docs-heading-anchor-permalink" href="#k-NN-Graph" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Graphs

function build_knn_graph(X::EuclideanSpace, k::Int)
    n = length(X)
    g = SimpleGraph(n)
    
    for i in 1:n
        neighbors = k_neighbors(X, X[i], k)
        for neighbor_idx in neighbors
            if neighbor_idx != i  # Avoid self-loops
                add_edge!(g, i, neighbor_idx)
            end
        end
    end
    
    return g
end

knn_graph = build_knn_graph(X, 2)
println(&quot;k-NN graph properties:&quot;)
println(&quot;Nodes: $(nv(knn_graph))&quot;)
println(&quot;Edges: $(ne(knn_graph))&quot;)
println(&quot;Connected components: $(length(connected_components(knn_graph)))&quot;)</code></pre><h3 id="ε-neighborhood-Graph"><a class="docs-heading-anchor" href="#ε-neighborhood-Graph">ε-neighborhood Graph</a><a id="ε-neighborhood-Graph-1"></a><a class="docs-heading-anchor-permalink" href="#ε-neighborhood-Graph" title="Permalink"></a></h3><pre><code class="language-julia hljs">function build_epsilon_graph(X::EuclideanSpace, ε::Float64)
    n = length(X)
    g = SimpleGraph(n)
    
    for i in 1:n
        neighbors = ball_ids(X, X[i], ε)
        for neighbor_idx in neighbors
            if neighbor_idx != i &amp;&amp; neighbor_idx &gt; i  # Avoid self-loops and duplicates
                add_edge!(g, i, neighbor_idx)
            end
        end
    end
    
    return g
end

eps_graph = build_epsilon_graph(X, 1.5)
println(&quot;ε-neighborhood graph properties:&quot;)
println(&quot;Nodes: $(nv(eps_graph))&quot;)
println(&quot;Edges: $(ne(eps_graph))&quot;)</code></pre><h2 id="Advanced-Neighborhood-Analysis"><a class="docs-heading-anchor" href="#Advanced-Neighborhood-Analysis">Advanced Neighborhood Analysis</a><a id="Advanced-Neighborhood-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Neighborhood-Analysis" title="Permalink"></a></h2><h3 id="Neighborhood-Stability"><a class="docs-heading-anchor" href="#Neighborhood-Stability">Neighborhood Stability</a><a id="Neighborhood-Stability-1"></a><a class="docs-heading-anchor-permalink" href="#Neighborhood-Stability" title="Permalink"></a></h3><p>Analyze how neighborhoods change under perturbations:</p><pre><code class="language-julia hljs">function neighborhood_stability(X::EuclideanSpace, k::Int, noise_level=0.1, n_trials=10)
    stability_scores = Float64[]
    
    for i in 1:length(X)
        original_neighbors = Set(k_neighbors(X, X[i], k))
        overlap_scores = Float64[]
        
        for trial in 1:n_trials
            # Add noise to the query point
            noisy_point = X[i] .+ noise_level * randn(length(X[i]))
            noisy_neighbors = Set(k_neighbors(X, noisy_point, k))
            
            # Compute Jaccard similarity
            intersection_size = length(intersect(original_neighbors, noisy_neighbors))
            union_size = length(union(original_neighbors, noisy_neighbors))
            jaccard = intersection_size / union_size
            
            push!(overlap_scores, jaccard)
        end
        
        push!(stability_scores, mean(overlap_scores))
    end
    
    return stability_scores
end

stability = neighborhood_stability(X, 3, 0.05, 5)
println(&quot;Neighborhood stability (mean): $(round(mean(stability), digits=3))&quot;)</code></pre><h3 id="Multi-scale-Neighborhoods"><a class="docs-heading-anchor" href="#Multi-scale-Neighborhoods">Multi-scale Neighborhoods</a><a id="Multi-scale-Neighborhoods-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-scale-Neighborhoods" title="Permalink"></a></h3><p>Analyze neighborhoods at different scales:</p><pre><code class="language-julia hljs">function multiscale_neighborhood_analysis(X::EuclideanSpace, point_idx::Int, radii=[0.5, 1.0, 1.5, 2.0])
    analysis = Dict{Float64, Dict{String, Any}}()
    
    for r in radii
        neighbors = ball_ids(X, X[point_idx], r)
        neighbor_points = [X[i] for i in neighbors]
        
        # Compute neighborhood statistics
        n_neighbors = length(neighbors)
        
        if n_neighbors &gt; 1
            # Average distance to neighbors
            center = X[point_idx]
            distances = [dist_euclidean(center, p) for p in neighbor_points]
            avg_dist = mean(distances)
            std_dist = std(distances)
            
            # Neighborhood &quot;spread&quot;
            if n_neighbors &gt; 2
                centroid = mean(neighbor_points)
                spreads = [norm(p .- centroid) for p in neighbor_points]
                neighborhood_spread = mean(spreads)
            else
                neighborhood_spread = 0.0
            end
        else
            avg_dist = 0.0
            std_dist = 0.0
            neighborhood_spread = 0.0
        end
        
        analysis[r] = Dict(
            &quot;n_neighbors&quot; =&gt; n_neighbors,
            &quot;avg_distance&quot; =&gt; avg_dist,
            &quot;std_distance&quot; =&gt; std_dist,
            &quot;neighborhood_spread&quot; =&gt; neighborhood_spread
        )
    end
    
    return analysis
end

# Analyze neighborhoods around the first point
multiscale_analysis = multiscale_neighborhood_analysis(X, 1)
println(&quot;Multi-scale neighborhood analysis for point 1:&quot;)
for (radius, stats) in sort(collect(multiscale_analysis))
    println(&quot;Radius $radius:&quot;)
    println(&quot;  Neighbors: $(stats[&quot;n_neighbors&quot;])&quot;)
    println(&quot;  Avg distance: $(round(stats[&quot;avg_distance&quot;], digits=3))&quot;)
    println(&quot;  Neighborhood spread: $(round(stats[&quot;neighborhood_spread&quot;], digits=3))&quot;)
end</code></pre><h2 id="Applications-in-Data-Analysis"><a class="docs-heading-anchor" href="#Applications-in-Data-Analysis">Applications in Data Analysis</a><a id="Applications-in-Data-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Applications-in-Data-Analysis" title="Permalink"></a></h2><h3 id="Clustering-Validation"><a class="docs-heading-anchor" href="#Clustering-Validation">Clustering Validation</a><a id="Clustering-Validation-1"></a><a class="docs-heading-anchor-permalink" href="#Clustering-Validation" title="Permalink"></a></h3><p>Use neighborhood analysis to validate clustering results:</p><pre><code class="language-julia hljs">function validate_clustering_with_neighborhoods(X::EuclideanSpace, cluster_labels, k::Int=5)
    n_clusters = maximum(cluster_labels)
    intra_cluster_cohesion = Float64[]
    
    for cluster_id in 1:n_clusters
        cluster_points = findall(x -&gt; x == cluster_id, cluster_labels)
        
        if length(cluster_points) &gt; k
            cohesion_scores = Float64[]
            
            for point_idx in cluster_points
                neighbors = k_neighbors(X, X[point_idx], k)
                # Count how many neighbors are in the same cluster
                same_cluster_neighbors = sum(cluster_labels[neighbors] .== cluster_id)
                cohesion = same_cluster_neighbors / k
                push!(cohesion_scores, cohesion)
            end
            
            push!(intra_cluster_cohesion, mean(cohesion_scores))
        end
    end
    
    return mean(intra_cluster_cohesion)
end

# Example with simple clustering
cluster_labels = [1, 1, 1, 2, 2, 2]  # Simple manual clustering
cohesion = validate_clustering_with_neighborhoods(X, cluster_labels, 2)
println(&quot;Clustering cohesion score: $(round(cohesion, digits=3))&quot;)</code></pre><h3 id="Anomaly-Detection"><a class="docs-heading-anchor" href="#Anomaly-Detection">Anomaly Detection</a><a id="Anomaly-Detection-1"></a><a class="docs-heading-anchor-permalink" href="#Anomaly-Detection" title="Permalink"></a></h3><p>Combine multiple neighborhood-based measures:</p><pre><code class="language-julia hljs">function comprehensive_anomaly_detection(X::EuclideanSpace)
    # Compute multiple measures
    dtm_vals = distance_to_measure(X, 0.1)
    ecc_vals = excentricity(X)
    
    # Local density (inverse of average k-NN distance)
    k = min(5, length(X) - 1)
    local_densities = Float64[]
    
    for i in 1:length(X)
        if length(X) &gt; 1
            neighbors = k_neighbors(X, X[i], min(k, length(X)-1))
            avg_dist = mean([dist_euclidean(X[i], X[j]) for j in neighbors if j != i])
            push!(local_densities, 1.0 / (avg_dist + 1e-10))
        else
            push!(local_densities, 1.0)
        end
    end
    
    # Normalize measures to [0, 1]
    dtm_norm = (dtm_vals .- minimum(dtm_vals)) ./ (maximum(dtm_vals) - minimum(dtm_vals) + 1e-10)
    ecc_norm = (ecc_vals .- minimum(ecc_vals)) ./ (maximum(ecc_vals) - minimum(ecc_vals) + 1e-10)
    density_norm = 1.0 .- ((local_densities .- minimum(local_densities)) ./ (maximum(local_densities) - minimum(local_densities) + 1e-10))
    
    # Combine measures (equal weights)
    anomaly_scores = (dtm_norm .+ ecc_norm .+ density_norm) ./ 3
    
    return anomaly_scores
end

anomaly_scores = comprehensive_anomaly_detection(X_outliers)
println(&quot;Top 3 anomalies:&quot;)
top_anomalies = sortperm(anomaly_scores, rev=true)[1:3]
for (rank, idx) in enumerate(top_anomalies)
    println(&quot;  $rank: Point $idx (score: $(round(anomaly_scores[idx], digits=3)))&quot;)
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sampling/">« Sampling Methods</a><a class="docs-footer-nextpage" href="../datasets/">Datasets »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Thursday 12 June 2025 01:53">Thursday 12 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
