import{_ as p,C as r,c as o,o as h,j as i,ai as l,a as t,G as a,w as n}from"./chunks/framework.BOY7Cjhz.js";const V=JSON.parse('{"title":"API Reference","description":"","frontmatter":{},"headers":[],"relativePath":"api.md","filePath":"api.md","lastUpdated":null}'),d={name:"api.md"},c={class:"jldocstring custom-block",open:""},k={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},u={class:"jldocstring custom-block",open:""},E={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},b={class:"jldocstring custom-block",open:""},f={class:"jldocstring custom-block",open:""},F={class:"jldocstring custom-block",open:""},C={class:"jldocstring custom-block",open:""},_={class:"jldocstring custom-block",open:""},S={class:"jldocstring custom-block",open:""},A={class:"jldocstring custom-block",open:""},T={class:"jldocstring custom-block",open:""},j={class:"jldocstring custom-block",open:""},M={class:"jldocstring custom-block",open:""},D={class:"jldocstring custom-block",open:""},v={class:"jldocstring custom-block",open:""},x={class:"jldocstring custom-block",open:""};function B(w,s,N,I,X,P){const e=r("Badge");return h(),o("div",null,[s[82]||(s[82]=i("h1",{id:"API-Reference",tabindex:"-1"},[t("API Reference "),i("a",{class:"header-anchor",href:"#API-Reference","aria-label":'Permalink to "API Reference {#API-Reference}"'},"​")],-1)),s[83]||(s[83]=i("p",null,"Complete reference for all exported functions and types in MetricSpaces.jl.",-1)),s[84]||(s[84]=i("h2",{id:"Core-Types",tabindex:"-1"},[t("Core Types "),i("a",{class:"header-anchor",href:"#Core-Types","aria-label":'Permalink to "Core Types {#Core-Types}"'},"​")],-1)),i("details",c,[i("summary",null,[s[0]||(s[0]=i("a",{id:"MetricSpaces.MetricSpace",href:"#MetricSpaces.MetricSpace"},[i("span",{class:"jlbinding"},"MetricSpaces.MetricSpace")],-1)),s[1]||(s[1]=t()),a(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[3]||(s[3]=i("p",null,"The abstract Metric Space type is just an alias for Vector{T}.",-1)),a(e,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[2]||(s[2]=[i("a",{href:"https://github.com/JuliaTDA/MetricSpaces.jl/blob/c8b110cf94640deb7ed9a0cf71e6e7d7745003e2/src/base/types.jl#L4-L7",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[2]})]),i("details",k,[i("summary",null,[s[4]||(s[4]=i("a",{id:"MetricSpaces.EuclideanSpace",href:"#MetricSpaces.EuclideanSpace"},[i("span",{class:"jlbinding"},"MetricSpaces.EuclideanSpace")],-1)),s[5]||(s[5]=t()),a(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[7]||(s[7]=i("p",null,"A type to model metric spaces where each element is an array of the same length.",-1)),a(e,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[6]||(s[6]=[i("a",{href:"https://github.com/JuliaTDA/MetricSpaces.jl/blob/c8b110cf94640deb7ed9a0cf71e6e7d7745003e2/src/base/types.jl#L9-L11",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[6]})]),i("details",g,[i("summary",null,[s[8]||(s[8]=i("a",{id:"MetricSpaces.as_matrix",href:"#MetricSpaces.as_matrix"},[i("span",{class:"jlbinding"},"MetricSpaces.as_matrix")],-1)),s[9]||(s[9]=t()),a(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[11]||(s[11]=l('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">as_matrix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">EuclideanSpace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Convert an Euclidean space into a matrix.</p>',2)),a(e,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[10]||(s[10]=[i("a",{href:"https://github.com/JuliaTDA/MetricSpaces.jl/blob/c8b110cf94640deb7ed9a0cf71e6e7d7745003e2/src/base/types.jl#L78-L82",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[10]})]),i("details",u,[i("summary",null,[s[12]||(s[12]=i("a",{id:"MetricSpaces.SubsetIndex",href:"#MetricSpaces.SubsetIndex"},[i("span",{class:"jlbinding"},"MetricSpaces.SubsetIndex")],-1)),s[13]||(s[13]=t()),a(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[15]||(s[15]=i("p",null,"A vector of integers, generally interpreted as indexes of a metric space.",-1)),a(e,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[14]||(s[14]=[i("a",{href:"https://github.com/JuliaTDA/MetricSpaces.jl/blob/c8b110cf94640deb7ed9a0cf71e6e7d7745003e2/src/base/types.jl#L96-L99",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[14]})]),i("details",E,[i("summary",null,[s[16]||(s[16]=i("a",{id:"MetricSpaces.Covering",href:"#MetricSpaces.Covering"},[i("span",{class:"jlbinding"},"MetricSpaces.Covering")],-1)),s[17]||(s[17]=t()),a(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[19]||(s[19]=i("p",null,[t("A covering is a vector of metric spaces, where each metric space is a subset of the original metric space "),i("code",null,"X"),t(".")],-1)),a(e,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[18]||(s[18]=[i("a",{href:"https://github.com/JuliaTDA/MetricSpaces.jl/blob/c8b110cf94640deb7ed9a0cf71e6e7d7745003e2/src/base/types.jl#L108-L111",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[18]})]),s[85]||(s[85]=i("h2",{id:"Distance-Functions",tabindex:"-1"},[t("Distance Functions "),i("a",{class:"header-anchor",href:"#Distance-Functions","aria-label":'Permalink to "Distance Functions {#Distance-Functions}"'},"​")],-1)),i("details",y,[i("summary",null,[s[20]||(s[20]=i("a",{id:"MetricSpaces.pairwise_distance",href:"#MetricSpaces.pairwise_distance"},[i("span",{class:"jlbinding"},"MetricSpaces.pairwise_distance")],-1)),s[21]||(s[21]=t()),a(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[24]||(s[24]=l('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pairwise_distance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(M</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, N</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, d) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {S </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MetricSpace{T}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {T}}</span></span></code></pre></div><p>Compute the pairwise distances between all elements of metric spaces <code>M</code> and <code>N</code> using the distance function <code>d</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>M::S</code>: A metric space of type <code>S</code>, where <code>S</code> is a subtype of <code>MetricSpace</code>.</p></li><li><p><code>N::S</code>: Another metric space of the same type as <code>M</code>.</p></li><li><p><code>d</code>: A function that computes the distance between two elements.</p></li></ul><p><strong>Returns</strong></p><ul><li>A matrix of size <code>length(M) × length(N)</code> where the entry <code>(i, j)</code> contains the distance <code>d(M[i], N[j])</code>.</li></ul><p><strong>Notes</strong></p><ul><li><p>The computation is parallelized across threads for improved performance.</p></li><li><p>Progress is displayed using a progress bar.</p></li></ul>',8)),a(e,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[22]||(s[22]=[i("a",{href:"https://github.com/JuliaTDA/MetricSpaces.jl/blob/c8b110cf94640deb7ed9a0cf71e6e7d7745003e2/src/base/distances.jl#L1-L17",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[22]}),s[25]||(s[25]=l('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pairwise_distance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(M</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, N</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Metric</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {S </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> EuclideanSpace{N, T}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {N, T}}</span></span></code></pre></div><p>Compute the pairwise distances between all elements in the collections <code>M</code> and <code>N</code> using the metric <code>d</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>M::S</code>: A collection of points in a Euclidean space.</p></li><li><p><code>N::S</code>: Another collection of points in the same Euclidean space as <code>M</code>.</p></li><li><p><code>d::Metric</code>: A metric function to compute the distance between points.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>s::Matrix{Float64}</code>: A matrix where the entry <code>s[i, j]</code> contains the distance between <code>M[i]</code> and <code>N[j]</code>.</li></ul><p><strong>Notes</strong></p><ul><li><p>The computation is parallelized across threads for efficiency.</p></li><li><p>Progress is displayed using a progress bar.</p></li><li><p>The function assumes that <code>M</code> and <code>N</code> are compatible with the provided metric and space type.</p></li></ul>',8)),a(e,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[23]||(s[23]=[i("a",{href:"https://github.com/JuliaTDA/MetricSpaces.jl/blob/c8b110cf94640deb7ed9a0cf71e6e7d7745003e2/src/base/distances.jl#L45-L62",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[23]})]),i("details",m,[i("summary",null,[s[26]||(s[26]=i("a",{id:"MetricSpaces.pairwise_distance_summary",href:"#MetricSpaces.pairwise_distance_summary"},[i("span",{class:"jlbinding"},"MetricSpaces.pairwise_distance_summary")],-1)),s[27]||(s[27]=t()),a(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[29]||(s[29]=l('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pairwise_distance_summary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(M</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, N</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, d, summary_function </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mean) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {S </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MetricSpace{T}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {T}}</span></span></code></pre></div><p>Compute a summary statistic of pairwise distances between each element of metric space <code>M</code> and all elements of metric space <code>N</code> using the distance function <code>d</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>M::S</code>: A metric space (or collection of points) of type <code>S</code>.</p></li><li><p><code>N::S</code>: Another metric space (or collection of points) of type <code>S</code>.</p></li><li><p><code>d</code>: A function that computes the distance between two points.</p></li><li><p><code>summary_function</code>: (Optional) A function to summarize the distances for each element of <code>M</code> (default is <code>mean</code>).</p></li></ul><p><strong>Returns</strong></p><ul><li><code>s</code>: An array where each entry <code>s[i]</code> contains the summary statistic (e.g., mean) of the distances from the <code>i</code>-th element of <code>M</code> to all elements of <code>N</code>.</li></ul><p><strong>Notes</strong></p><ul><li><p>The computation is parallelized using threads for improved performance.</p></li><li><p>Progress is displayed using a progress bar.</p></li></ul>',8)),a(e,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[28]||(s[28]=[i("a",{href:"https://github.com/JuliaTDA/MetricSpaces.jl/blob/c8b110cf94640deb7ed9a0cf71e6e7d7745003e2/src/base/distances.jl#L79-L96",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[28]})]),s[86]||(s[86]=i("h2",{id:"Norm-Functions",tabindex:"-1"},[t("Norm Functions "),i("a",{class:"header-anchor",href:"#Norm-Functions","aria-label":'Permalink to "Norm Functions {#Norm-Functions}"'},"​")],-1)),i("details",b,[i("summary",null,[s[30]||(s[30]=i("a",{id:"MetricSpaces.norm",href:"#MetricSpaces.norm"},[i("span",{class:"jlbinding"},"MetricSpaces.norm")],-1)),s[31]||(s[31]=t()),a(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[33]||(s[33]=l('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Euclidean norm.</span></span></code></pre></div>',1)),a(e,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[32]||(s[32]=[i("a",{href:"https://github.com/JuliaTDA/MetricSpaces.jl/blob/c8b110cf94640deb7ed9a0cf71e6e7d7745003e2/src/base/norm.jl#L2-L4",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[32]})]),s[87]||(s[87]=i("h2",{id:"Ball-Operations",tabindex:"-1"},[t("Ball Operations "),i("a",{class:"header-anchor",href:"#Ball-Operations","aria-label":'Permalink to "Ball Operations {#Ball-Operations}"'},"​")],-1)),i("details",f,[i("summary",null,[s[34]||(s[34]=i("a",{id:"MetricSpaces.ball",href:"#MetricSpaces.ball"},[i("span",{class:"jlbinding"},"MetricSpaces.ball")],-1)),s[35]||(s[35]=t()),a(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[37]||(s[37]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ball</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MetricSpace{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ϵ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, distance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dist_euclidean) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {T}</span></span></code></pre></div><p>Extract the subset of points from metric space <code>X</code> that are within distance <code>ϵ</code> from point <code>x</code>.</p><p>This function returns the actual points (not just indices) that form the ball B(x, ϵ) = {y ∈ X : d(x, y) &lt; ϵ} around the center point <code>x</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>X::MetricSpace{T}</code>: The metric space containing the points to search</p></li><li><p><code>x::T</code>: The center point of the ball</p></li><li><p><code>ϵ::Number</code>: The radius of the ball (must be positive)</p></li><li><p><code>distance</code>: Distance function to use (default: <code>dist_euclidean</code>)</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>MetricSpace</code>: A new metric space containing only the points within the ball</p></li><li><p>Returns an empty metric space if no points are found within the radius</p></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Create a 1D Euclidean space</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">X </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> EuclideanSpace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">reshape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Get points within distance 1.5 from [3.0]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">subset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ball</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(X, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Contains points [2.0, 3.0, 4.0]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Using Manhattan distance</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">subset_l1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ball</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(X, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dist_cityblock)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Check if result is empty</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ball</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(X, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isempty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># true</span></span></code></pre></div><p><strong>Implementation Details</strong></p><ul><li><p>Internally uses <a href="/MetricSpaces.jl/stable/api#MetricSpaces.ball_ids"><code>ball_ids</code></a> to find the relevant indices</p></li><li><p>Preserves the metric space structure in the returned subset</p></li><li><p>The distance function should be compatible with the metric space type</p></li></ul><p><strong>Mathematical Definition</strong></p><p>For a metric space (X, d) and point x ∈ X, the open ball of radius ϵ is: B(x, ϵ) = {y ∈ X : d(x, y) &lt; ϵ}</p><p>See also: <a href="/MetricSpaces.jl/stable/api#MetricSpaces.ball_ids"><code>ball_ids</code></a>, <a href="/MetricSpaces.jl/stable/api#MetricSpaces.pairwise_distance"><code>pairwise_distance</code></a></p>`,14)),a(e,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[36]||(s[36]=[i("a",{href:"https://github.com/JuliaTDA/MetricSpaces.jl/blob/c8b110cf94640deb7ed9a0cf71e6e7d7745003e2/src/base/ball.jl#L53-L97",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[36]})]),i("details",F,[i("summary",null,[s[38]||(s[38]=i("a",{id:"MetricSpaces.ball_ids",href:"#MetricSpaces.ball_ids"},[i("span",{class:"jlbinding"},"MetricSpaces.ball_ids")],-1)),s[39]||(s[39]=t()),a(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[41]||(s[41]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ball_ids</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MetricSpace{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ϵ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, distance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dist_euclidean) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {T}</span></span></code></pre></div><p>Find the indices of points in metric space <code>X</code> that are within distance <code>ϵ</code> from point <code>x</code>.</p><p>This function computes the ball B(x, ϵ) = {y ∈ X : d(x, y) &lt; ϵ} and returns the indices of points in X that belong to this open ball.</p><p><strong>Arguments</strong></p><ul><li><p><code>X::MetricSpace{T}</code>: The metric space containing the points to search</p></li><li><p><code>x::T</code>: The center point of the ball</p></li><li><p><code>ϵ::Number</code>: The radius of the ball (must be positive)</p></li><li><p><code>distance</code>: Distance function to use (default: <code>dist_euclidean</code>)</p></li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Int}</code>: Indices of points in <code>X</code> that are within distance <code>ϵ</code> from <code>x</code></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Create a 1D Euclidean space</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">X </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> EuclideanSpace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">reshape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Find indices of points within distance 1.5 from point [3.0]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ball_ids</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(X, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Returns [2, 3, 4]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Using a different distance function</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ball_ids</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(X, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dist_cityblock)</span></span></code></pre></div><p><strong>Notes</strong></p><ul><li><p>Uses strict inequality (d &lt; ϵ), so points exactly at distance ϵ are excluded</p></li><li><p>For empty results, returns an empty vector</p></li><li><p>The distance function should be compatible with the metric space type</p></li></ul><p>See also: <a href="/MetricSpaces.jl/stable/api#MetricSpaces.ball"><code>ball</code></a>, <a href="/MetricSpaces.jl/stable/api#MetricSpaces.pairwise_distance"><code>pairwise_distance</code></a></p>`,12)),a(e,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[40]||(s[40]=[i("a",{href:"https://github.com/JuliaTDA/MetricSpaces.jl/blob/c8b110cf94640deb7ed9a0cf71e6e7d7745003e2/src/base/ball.jl#L1-L36",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[40]})]),s[88]||(s[88]=i("h2",{id:"Neighborhood-Analysis",tabindex:"-1"},[t("Neighborhood Analysis "),i("a",{class:"header-anchor",href:"#Neighborhood-Analysis","aria-label":'Permalink to "Neighborhood Analysis {#Neighborhood-Analysis}"'},"​")],-1)),i("details",C,[i("summary",null,[s[42]||(s[42]=i("a",{id:"MetricSpaces.k_neighbors",href:"#MetricSpaces.k_neighbors"},[i("span",{class:"jlbinding"},"MetricSpaces.k_neighbors")],-1)),s[43]||(s[43]=t()),a(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[45]||(s[45]=l('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">k_neighbors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MetricSpace{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dist_euclidean) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {T}</span></span></code></pre></div><p>Finds the <code>k</code> nearest neighbors of a given point <code>x</code> in the metric space <code>X</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>X::MetricSpace{T}</code>: The metric space containing the points.</p></li><li><p><code>x::T</code>: The query point for which the nearest neighbors are to be found.</p></li><li><p><code>k::Int</code>: The number of nearest neighbors to retrieve.</p></li><li><p><code>d</code>: The distance function to use for computing distances. Defaults to <code>dist_euclidean</code>.</p></li></ul><p><strong>Returns</strong></p><ul><li>A collection of the <code>k</code> nearest neighbors of <code>x</code> in <code>X</code>.</li></ul><p><strong>Notes</strong></p><p>This function internally uses <code>k_neighbors_ids</code> to retrieve the indices of the nearest neighbors and then returns the corresponding elements from <code>X</code>.</p>',8)),a(e,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[44]||(s[44]=[i("a",{href:"https://github.com/JuliaTDA/MetricSpaces.jl/blob/c8b110cf94640deb7ed9a0cf71e6e7d7745003e2/src/extra/neighborhood.jl#L28-L44",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[44]})]),i("details",_,[i("summary",null,[s[46]||(s[46]=i("a",{id:"MetricSpaces.distance_to_measure",href:"#MetricSpaces.distance_to_measure"},[i("span",{class:"jlbinding"},"MetricSpaces.distance_to_measure")],-1)),s[47]||(s[47]=t()),a(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[49]||(s[49]=l('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">distance_to_measure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, Y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dist_euclidean, k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, summary_function</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">maximum) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {S </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MetricSpace{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Computes a measure of distance from each point in the metric space <code>X</code> to the metric space <code>Y</code>. For each point in <code>X</code>, the function calculates the distances to the <code>k</code> nearest neighbors in <code>Y</code> using the provided distance function <code>d</code> (default is <code>dist_euclidean</code>). The resulting distances are summarized using the specified <code>summary_function</code> (default is <code>maximum</code>).</p><p><strong>Arguments</strong></p><ul><li><p><code>X::S</code>: A metric space of type <code>S</code> containing the points to measure distances from.</p></li><li><p><code>Y::S</code>: A metric space of type <code>S</code> containing the points to measure distances to.</p></li><li><p><code>d</code>: A distance function to compute the distance between points in <code>X</code> and <code>Y</code>. Defaults to <code>dist_euclidean</code>.</p></li><li><p><code>k::Integer</code>: The number of nearest neighbors in <code>Y</code> to consider for each point in <code>X</code>. Defaults to <code>5</code>.</p></li><li><p><code>summary_function</code>: A function to summarize the <code>k</code> nearest distances. Defaults to <code>maximum</code>.</p></li></ul><p><strong>Returns</strong></p><ul><li>A vector of summarized distances for each point in <code>X</code>.</li></ul><p><strong>Notes</strong></p><ul><li><p>The computation is parallelized using <code>Threads.@threads</code> for improved performance.</p></li><li><p>The function assumes that the input metric spaces <code>X</code> and <code>Y</code> are compatible with the provided distance function <code>d</code>.</p></li></ul>',8)),a(e,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[48]||(s[48]=[i("a",{href:"https://github.com/JuliaTDA/MetricSpaces.jl/blob/c8b110cf94640deb7ed9a0cf71e6e7d7745003e2/src/extra/filters.jl#L1-L20",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[48]})]),i("details",S,[i("summary",null,[s[50]||(s[50]=i("a",{id:"MetricSpaces.excentricity",href:"#MetricSpaces.excentricity"},[i("span",{class:"jlbinding"},"MetricSpaces.excentricity")],-1)),s[51]||(s[51]=t()),a(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[53]||(s[53]=l('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">excentricity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, Y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dist_euclidean) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {S </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MetricSpace{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Computes the excentricity of the metric space <code>X</code> with respect to the metric space <code>Y</code>. The excentricity is defined as the mean of the pairwise distances between points in <code>X</code> and <code>Y</code>, using the provided distance function <code>d</code> (default is <code>dist_euclidean</code>).</p><p><strong>Arguments</strong></p><ul><li><p><code>X::S</code>: A metric space of type <code>S</code> containing the points to compute excentricity for.</p></li><li><p><code>Y::S</code>: A metric space of type <code>S</code> containing the points to compute distances to.</p></li><li><p><code>d</code>: A distance function to compute the distance between points in <code>X</code> and <code>Y</code>. Defaults to <code>dist_euclidean</code>.</p></li></ul><p><strong>Returns</strong></p><ul><li>A scalar value representing the excentricity of <code>X</code> with respect to <code>Y</code>.</li></ul><p><strong>Notes</strong></p><ul><li>This function internally uses <code>pairwise_distance_summary</code> with the <code>mean</code> function to compute the excentricity.</li></ul>',8)),a(e,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[52]||(s[52]=[i("a",{href:"https://github.com/JuliaTDA/MetricSpaces.jl/blob/c8b110cf94640deb7ed9a0cf71e6e7d7745003e2/src/extra/filters.jl#L39-L54",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[52]})]),s[89]||(s[89]=i("h2",{id:"Sampling-Methods",tabindex:"-1"},[t("Sampling Methods "),i("a",{class:"header-anchor",href:"#Sampling-Methods","aria-label":'Permalink to "Sampling Methods {#Sampling-Methods}"'},"​")],-1)),i("details",A,[i("summary",null,[s[54]||(s[54]=i("a",{id:"MetricSpaces.epsilon_net",href:"#MetricSpaces.epsilon_net"},[i("span",{class:"jlbinding"},"MetricSpaces.epsilon_net")],-1)),s[55]||(s[55]=t()),a(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[57]||(s[57]=l('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">epsilon_net</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MetricSpace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ϵ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dist_euclidean)</span></span></code></pre></div><p>Constructs an epsilon-net for a given metric space <code>X</code>. An epsilon-net is a subset of points (landmarks) such that every point in <code>X</code> is within a distance <code>ϵ</code> of at least one landmark.</p><p><strong>Arguments</strong></p><ul><li><p><code>X::MetricSpace</code>: The metric space containing the points.</p></li><li><p><code>ϵ::Number</code>: The radius of the epsilon ball used to cover the points.</p></li><li><p><code>d</code>: A distance function to compute pairwise distances. Defaults to <code>dist_euclidean</code>.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>landmarks::Vector{Int}</code>: A vector of indices representing the selected landmarks.</li></ul><p><strong>Details</strong></p><p>The function iteratively selects points from <code>X</code> that are not yet covered by the epsilon balls of previously selected landmarks. It uses a progress meter to track the process and terminates when all points in <code>X</code> are covered.</p>',8)),a(e,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[56]||(s[56]=[i("a",{href:"https://github.com/JuliaTDA/MetricSpaces.jl/blob/c8b110cf94640deb7ed9a0cf71e6e7d7745003e2/src/extra/sampling.jl#L3-L18",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[56]})]),i("details",T,[i("summary",null,[s[58]||(s[58]=i("a",{id:"MetricSpaces.farthest_points_sample",href:"#MetricSpaces.farthest_points_sample"},[i("span",{class:"jlbinding"},"MetricSpaces.farthest_points_sample")],-1)),s[59]||(s[59]=t()),a(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[61]||(s[61]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">farthest_points_sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MetricSpace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> euclidean)</span></span></code></pre></div><p>Sample <code>n</code> points from a metric space <code>X</code> using the Farthest Point Sampling (FPS) algorithm.</p><p>This method iteratively selects points that are farthest from the already selected points, resulting in a well-distributed subset of points from the original space.</p><p><strong>Arguments</strong></p><ul><li><p><code>X::MetricSpace</code>: The input metric space to sample from</p></li><li><p><code>n::Integer</code>: Number of points to sample</p></li><li><p><code>d</code>: Distance function to use (defaults to euclidean distance)</p></li></ul><p><strong>Returns</strong></p><ul><li>A subset of <code>n</code> points from <code>X</code> that are approximately maximally distant from each other</li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">X </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> EuclideanSpace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sampled_points </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> farthest_points_sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(X, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>Details</strong></p><p>The algorithm works as follows:</p><ol><li><p>Randomly select the first point from <code>X</code>.</p></li><li><p>For each subsequent point, compute the distance to all previously selected points.</p></li><li><p>Select the point that is farthest from the previously selected points.</p></li><li><p>Repeat until <code>n</code> points are selected.</p></li></ol><p><strong>Complexity</strong></p><p>The algorithm runs in O(kN) time, where k is the number of points to sample and N is the total number of points in <code>X</code>.</p>`,14)),a(e,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[60]||(s[60]=[i("a",{href:"https://github.com/JuliaTDA/MetricSpaces.jl/blob/c8b110cf94640deb7ed9a0cf71e6e7d7745003e2/src/extra/sampling.jl#L112-L143",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[60]})]),i("details",j,[i("summary",null,[s[62]||(s[62]=i("a",{id:"MetricSpaces.random_sample",href:"#MetricSpaces.random_sample"},[i("span",{class:"jlbinding"},"MetricSpaces.random_sample")],-1)),s[63]||(s[63]=t()),a(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[65]||(s[65]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">random_sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MetricSpace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Randomly sample <code>n</code> points from a metric space <code>X</code> without replacement.</p><p><strong>Arguments</strong></p><ul><li><p><code>X::MetricSpace</code>: The metric space to sample from</p></li><li><p><code>n::Integer = 1000</code>: The number of points to sample (default: 1000)</p></li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: A vector containing <code>min(length(X), n)</code> randomly sampled points from <code>X</code></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">X </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> EuclideanSpace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sampled_points </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> random_sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(X, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div>`,8)),a(e,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[64]||(s[64]=[i("a",{href:"https://github.com/JuliaTDA/MetricSpaces.jl/blob/c8b110cf94640deb7ed9a0cf71e6e7d7745003e2/src/extra/sampling.jl#L149-L166",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[64]})]),s[90]||(s[90]=i("h2",{id:"Dataset-Generation",tabindex:"-1"},[t("Dataset Generation "),i("a",{class:"header-anchor",href:"#Dataset-Generation","aria-label":'Permalink to "Dataset Generation {#Dataset-Generation}"'},"​")],-1)),i("details",M,[i("summary",null,[s[66]||(s[66]=i("a",{id:"MetricSpaces.sphere",href:"#MetricSpaces.sphere"},[i("span",{class:"jlbinding"},"MetricSpaces.sphere")],-1)),s[67]||(s[67]=t()),a(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[69]||(s[69]=l('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sphere</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(num_points</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, radius</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Number</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, noise</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Function</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> zeros)</span></span></code></pre></div><p>Generates a set of points uniformly distributed on the surface of a sphere in the Euclidean space.</p><p><strong>Arguments</strong></p><ul><li><p><code>num_points::Integer=100</code>: The number of points to generate on the sphere.</p></li><li><p><code>dim::Integer=2</code>: The dimensionality of the sphere.</p></li><li><p><code>radius::Number=1</code>: The radius of the sphere.</p></li><li><p><code>noise::Function=zeros</code>: A function that generates noise to be added to each point. The function should accept the dimensionality <code>dim</code> as an argument and return a vector of the same size.</p></li></ul><p><strong>Returns</strong></p><ul><li>An instance of <code>EuclideanSpace</code> containing the generated points.</li></ul><p><strong>Example</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>sphere(100, dim=3, radius=2.0, noise=randn)</span></span></code></pre></div><p>end</p>',9)),a(e,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[68]||(s[68]=[i("a",{href:"https://github.com/JuliaTDA/MetricSpaces.jl/blob/c8b110cf94640deb7ed9a0cf71e6e7d7745003e2/src/extra/datasets.jl#L1-L18",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[68]})]),i("details",D,[i("summary",null,[s[70]||(s[70]=i("a",{id:"MetricSpaces.torus",href:"#MetricSpaces.torus"},[i("span",{class:"jlbinding"},"MetricSpaces.torus")],-1)),s[71]||(s[71]=t()),a(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[73]||(s[73]=l('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">torus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(num_points</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; r</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Number</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, R</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Number</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>Arguments</strong></p><ul><li><p><code>num_points::Integer</code>: the number of points.</p></li><li><p><code>r::Number</code>: the inner radius.</p></li><li><p><code>R::Number</code>: the outer radius.</p></li></ul>',3)),a(e,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[72]||(s[72]=[i("a",{href:"https://github.com/JuliaTDA/MetricSpaces.jl/blob/c8b110cf94640deb7ed9a0cf71e6e7d7745003e2/src/extra/datasets.jl#L58-L65",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[72]})]),i("details",v,[i("summary",null,[s[74]||(s[74]=i("a",{id:"MetricSpaces.cube",href:"#MetricSpaces.cube"},[i("span",{class:"jlbinding"},"MetricSpaces.cube")],-1)),s[75]||(s[75]=t()),a(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[77]||(s[77]=l(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cube</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(num_points</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, radius</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Number</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, noise</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Function</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> zeros)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cube</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    num_points</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    radius</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Number</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    noise</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Function</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> zeros</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    )</span></span></code></pre></div><p>Create a cube in R^(<code>dim</code>) with <code>num_points</code> points and radius <code>radius</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>num_points::Integer</code>: the number of points.</p></li><li><p><code>dim::Integer</code>: the dimension of the cube (that is: in which R^dim it is).</p></li><li><p><code>radius::Number</code>: the &quot;radius&quot; of the cube, that is, the distance from the center to one of its sides..</p></li><li><p><code>noise::Function</code>: a function such that <code>y = noise(dim)</code> is a <code>Vector{&lt;:Number}</code> with <code>size(y) = (dim;)</code>.</p></li></ul>`,4)),a(e,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[76]||(s[76]=[i("a",{href:"https://github.com/JuliaTDA/MetricSpaces.jl/blob/c8b110cf94640deb7ed9a0cf71e6e7d7745003e2/src/extra/datasets.jl#L31-L47",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[76]})]),s[91]||(s[91]=i("h2",{id:"Nerve-Construction",tabindex:"-1"},[t("Nerve Construction "),i("a",{class:"header-anchor",href:"#Nerve-Construction","aria-label":'Permalink to "Nerve Construction {#Nerve-Construction}"'},"​")],-1)),i("details",x,[i("summary",null,[s[78]||(s[78]=i("a",{id:"MetricSpaces.nerve_1d",href:"#MetricSpaces.nerve_1d"},[i("span",{class:"jlbinding"},"MetricSpaces.nerve_1d")],-1)),s[79]||(s[79]=t()),a(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[81]||(s[81]=l('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nerve_1d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CX</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CoveredPointCloud</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Given a covered point cloud <code>CX</code>, return the adjacency matrix of the 1-skeleton nerve of <code>CX.covering</code>.</p>',2)),a(e,{type:"info",class:"source-link",text:"source"},{default:n(()=>s[80]||(s[80]=[i("a",{href:"https://github.com/JuliaTDA/MetricSpaces.jl/blob/c8b110cf94640deb7ed9a0cf71e6e7d7745003e2/src/extra/nerve.jl#L1-L6",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[80]})]),s[92]||(s[92]=l('<h2 id="Index" tabindex="-1">Index <a class="header-anchor" href="#Index" aria-label="Permalink to &quot;Index {#Index}&quot;">​</a></h2><ul><li><a href="#MetricSpaces.Covering"><code>MetricSpaces.Covering</code></a></li><li><a href="#MetricSpaces.EuclideanSpace"><code>MetricSpaces.EuclideanSpace</code></a></li><li><a href="#MetricSpaces.MetricSpace"><code>MetricSpaces.MetricSpace</code></a></li><li><a href="#MetricSpaces.SubsetIndex"><code>MetricSpaces.SubsetIndex</code></a></li><li><a href="#MetricSpaces.as_matrix"><code>MetricSpaces.as_matrix</code></a></li><li><a href="#MetricSpaces.ball"><code>MetricSpaces.ball</code></a></li><li><a href="#MetricSpaces.ball_ids"><code>MetricSpaces.ball_ids</code></a></li><li><a href="#MetricSpaces.cube"><code>MetricSpaces.cube</code></a></li><li><a href="#MetricSpaces.distance_to_measure"><code>MetricSpaces.distance_to_measure</code></a></li><li><a href="#MetricSpaces.epsilon_net"><code>MetricSpaces.epsilon_net</code></a></li><li><a href="#MetricSpaces.excentricity"><code>MetricSpaces.excentricity</code></a></li><li><a href="#MetricSpaces.farthest_points_sample"><code>MetricSpaces.farthest_points_sample</code></a></li><li><a href="#MetricSpaces.k_neighbors"><code>MetricSpaces.k_neighbors</code></a></li><li><a href="#MetricSpaces.nerve_1d"><code>MetricSpaces.nerve_1d</code></a></li><li><a href="#MetricSpaces.norm"><code>MetricSpaces.norm</code></a></li><li><a href="#MetricSpaces.pairwise_distance"><code>MetricSpaces.pairwise_distance</code></a></li><li><a href="#MetricSpaces.pairwise_distance_summary"><code>MetricSpaces.pairwise_distance_summary</code></a></li><li><a href="#MetricSpaces.random_sample"><code>MetricSpaces.random_sample</code></a></li><li><a href="#MetricSpaces.sphere"><code>MetricSpaces.sphere</code></a></li><li><a href="#MetricSpaces.torus"><code>MetricSpaces.torus</code></a></li></ul>',2))])}const L=p(d,[["render",B]]);export{V as __pageData,L as default};
